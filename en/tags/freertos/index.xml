<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FreeRTOS on Hsing-Yu's Space</title><link>https://www.hugoshih.com/en/tags/freertos/</link><description>Recent content in FreeRTOS on Hsing-Yu's Space</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 06 Jan 2025 15:32:31 +0800</lastBuildDate><atom:link href="https://www.hugoshih.com/en/tags/freertos/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction and Comparison of Common Real-Time OS</title><link>https://www.hugoshih.com/en/p/introduction-and-comparison-of-common-real-time-os/</link><pubDate>Mon, 06 Jan 2025 15:32:31 +0800</pubDate><guid>https://www.hugoshih.com/en/p/introduction-and-comparison-of-common-real-time-os/</guid><description>&lt;img src="https://i.imgur.com/7SJYZ3b.jpg" alt="Featured image of post Introduction and Comparison of Common Real-Time OS" /&gt;&lt;h2 id="introduction"&gt;Introduction
&lt;/h2&gt;&lt;p&gt;A Real-Time Operating System (RTOS) is an operating system designed specifically for real-time applications, emphasizing &amp;ldquo;responding to events within a specific time limit (deadline)&amp;rdquo;. Imagine a scenario in the industrial field where a part of a machine suddenly malfunctions and needs to stop all motor operations in a very short time. If a traditional operating system like Linux is used, depending on the OS kernel scheduling policy, the action of stopping the motor may be slightly delayed. In contrast, an RTOS can have more flexible thread preemption, allowing emergency situations to be handled faster.&lt;/p&gt;
&lt;p&gt;Essentially, the kernel usage of RTOS is similar. Basically, they can achieve multiple thread creation, round-robin execution, priority preemption, mutex locks, kernel-level interrupts, etc. More advanced ones have dynamic memory management and multi-core support. The main differences between these RTOS lie in the support for peripheral modules and the surrounding development ecosystem. The following introduces several currently mainstream common RTOS:&lt;/p&gt;
&lt;h3 id="freertos"&gt;&lt;a class="link" href="https://github.com/FreeRTOS/FreeRTOS" target="_blank" rel="noopener"
&gt;FreeRTOS&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;FreeRTOS is maintained by Real Time Engineers Ltd. and Amazon. It is completely open source and widely used globally. FreeRTOS can be said to be the most common RTOS. Its success lies in being open source early, integrated by various IDEs early, and its shadow can be seen in the SDKs of various chips. I first contacted it in the Arduino IDE. FreeRTOS appeared in the Arduino library list very early. It is simple enough to use, without complex settings, and multi-threading can be implemented with a line or two of code, making it easy for beginners to enter the world of RTOS. Its backer is Amazon, and later it also integrated a lot of AWS IoT-related functions. Since it was open sourced early, there are many surrounding modules.&lt;/p&gt;
&lt;h3 id="azurertos-threadx"&gt;&lt;a class="link" href="https://github.com/eclipse-threadx/threadx" target="_blank" rel="noopener"
&gt;AzureRTOS (Threadx)&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;ThreadX is a real-time operating system (RTOS) developed by Express Logic. It was subsequently acquired by Microsoft and released as a renamed version AzureRTOS and open sourced. From the name, it can be seen that formerly it should be paired with Microsoft&amp;rsquo;s Azure to do some IoT functions, but currently, no killer application seems to have been seen. Because it was open sourced relatively late, there are fewer surrounding packages, such as BLE and Wifi stacks, but I believe with native support from Microsoft, it should grow quickly. I encountered AzureRTOS because STM32 officially supports AzureRTOS natively. Interestingly, the STM32 development environment also supports FreeRTOS, but the support is far inferior to AzureRTOS.&lt;/p&gt;
&lt;h3 id="zephyr"&gt;&lt;a class="link" href="https://github.com/zephyrproject-rtos/zephyr" target="_blank" rel="noopener"
&gt;Zephyr&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;Zephyr is an open-source real-time operating system (RTOS) led by the Linux Foundation. Although Zephyr has been around for a long time, it has only suddenly become popular in recent years. It features cross-platform compatibility and a complete development toolchain, with useful tools like West and architectures designed for cross-platform like DeviceTree. It can be said that to use Zephyr, you have to use this entire toolchain together to make it useful. However, it seems that due to the toolchain and compatibility reasons, although various chip manufacturers claim support, the support doesn&amp;rsquo;t seem to be that good, especially when it comes to very low-level hardware settings (like clock tree settings), it becomes particularly troublesome. if there is no such requirement, it is quite easy to use, and many settings and initializations are omitted for you. I encountered Zephyr because I used Nordic&amp;rsquo;s Bluetooth SoC. The latest nrf connect SDK is basically built on Zephyr, and Zephyr&amp;rsquo;s communication-related packages are also very complete, making it very suitable for Nordic chips.&lt;/p&gt;
&lt;h3 id="rt-thread"&gt;&lt;a class="link" href="https://github.com/RT-Thread/rt-thread" target="_blank" rel="noopener"
&gt;RT-Thread&lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;RT-Thread is an open-source real-time operating system (RTOS) led by a Chinese team. It is quite popular in China&amp;rsquo;s embedded system open source community and has good support for Chinese-made MCUs (especially some RISC-V chips), but it is rarely seen used elsewhere. Like Zephyr, there are many tools available. I haven&amp;rsquo;t used it myself yet, but what impressed me was that the RT-Thread community has a tool that can generate STM32 bootloader with one click. However, to use it, you need to register an account, and it is limited to registration with a Chinese phone number&amp;hellip;, which is not very friendly to developers outside of China.&lt;/p&gt;
&lt;h2 id="comparison"&gt;Comparison
&lt;/h2&gt;&lt;h3 id="differences-between-several-rtos"&gt;Differences between several RTOS
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;AzureRTOS (ThreadX)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FreeRTOS&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Zephyr&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;RT-Thread&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Maintainer&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Originally developed by Express Logic, now managed by Azure (Microsoft) &lt;br/&gt; - Open sourced after being bought by Microsoft&lt;/td&gt;
&lt;td&gt;- Maintained by AWS (Amazon) and large community &lt;br/&gt; - Open source project with broad community support&lt;/td&gt;
&lt;td&gt;- Hosted by Linux Foundation &lt;br/&gt; - Numerous major industry sponsors and contributors (e.g., Intel, Nordic, etc.)&lt;/td&gt;
&lt;td&gt;- Chinese embedded manufacturers and RT-Thread community&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;License&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- MIT License (Open Source Version)&lt;/td&gt;
&lt;td&gt;- MIT License &lt;br/&gt; - Completely open source, commercially usable&lt;/td&gt;
&lt;td&gt;- Apache 2.0 License &lt;br/&gt; - Completely open source&lt;/td&gt;
&lt;td&gt;- LGPL License &lt;br/&gt; - Commercially usable, but must comply with LGPL terms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Key Features&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Small memory footprint &lt;br/&gt; - High performance preemptive multitasking &lt;br/&gt; - Integrated debugging functions, other peripheral control modules&lt;/td&gt;
&lt;td&gt;- Modular design, highly customizable kernel &lt;br/&gt; - Cooperative and preemptive multitasking &lt;br/&gt; - Detailed documentation and huge community, high support&lt;/td&gt;
&lt;td&gt;- Good cross-platform compatibility &lt;br/&gt; - Complete tracking and analysis tools &lt;br/&gt; - Integration with Percepio Tracealyzer&lt;/td&gt;
&lt;td&gt;- Lightweight design and microkernel architecture &lt;br/&gt; - High efficiency, fast boot speed &lt;br/&gt; - Focus on modularity and ease of use&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Barrier to Entry&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Medium barrier &lt;br/&gt; - Provides specialized APIs and toolchains &lt;br/&gt; - Native support for STM32, less support for other chips&lt;/td&gt;
&lt;td&gt;- Low barrier &lt;br/&gt; - Comprehensive documentation and huge community &lt;br/&gt; - Relatively easy for beginners, low maintenance cost&lt;/td&gt;
&lt;td&gt;- High barrier &lt;br/&gt; - Must be familiar with a complete set of development toolchains &lt;br/&gt; - Rich community and corporate resources, difficulty depends on application depth&lt;/td&gt;
&lt;td&gt;- Medium barrier &lt;br/&gt; - Design is relatively simple and easy to understand &lt;br/&gt; - Modularity allows flexible expansion, but requires basic understanding of RTOS principles&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Community &amp;amp; Ecosystem&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- High industry support due to Microsoft Azure &lt;br/&gt; - Open sourced later, relatively less community support&lt;/td&gt;
&lt;td&gt;- Has an extremely wide user community &lt;br/&gt; - Rich third-party packages and forum resources&lt;/td&gt;
&lt;td&gt;- Company and open source community work together &lt;br/&gt; - Large manufacturers invest resources in development and provide hardware support &lt;br/&gt; - Documentation and package tools are maturing&lt;/td&gt;
&lt;td&gt;- Huge user base in Asian market &lt;br/&gt; - Community is growing, third-party resources are increasing year by year&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Scope of Application&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Consumer electronics, industrial equipment &lt;br/&gt; - Highly resource-constrained or high-performance applications&lt;/td&gt;
&lt;td&gt;- Widely used in various microcontrollers and embedded devices &lt;br/&gt; - Suitable for small and medium projects or prototype development&lt;/td&gt;
&lt;td&gt;- Products with high cross-platform compatibility &lt;br/&gt; - Devices requiring integration of multiple communication protocols&lt;/td&gt;
&lt;td&gt;- Small IoT devices, home appliances, industrial control, etc. &lt;br/&gt; - Suitable for scenarios with limited resources and high real-time requirements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Highly integrated SoC platforms &lt;br/&gt; - Network devices, medical instruments, consumer electronics &lt;br/&gt; - Systems with limited resources but requiring stability&lt;/td&gt;
&lt;td&gt;- IoT edge devices &lt;br/&gt; - Small sensors, portable products &lt;br/&gt; - Industrial automation control&lt;/td&gt;
&lt;td&gt;- High-speed communication equipment &lt;br/&gt; - Industrial equipment requiring complete tracking and debugging capabilities &lt;br/&gt; - Precision instruments and high reliability applications&lt;/td&gt;
&lt;td&gt;- Embedded microcontrollers &lt;br/&gt; - Smart home and wearable devices &lt;br/&gt; - Scenarios requiring fast boot and efficient scheduling&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="differences-in-kernel-features"&gt;Differences in Kernel Features
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;AzureRTOS (ThreadX)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FreeRTOS&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Zephyr&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;RT-Thread&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Kernel Architecture&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Lightweight, modular design &lt;br/&gt; - Single-core real-time system &lt;br/&gt; - Provides preemption-threshold&lt;/td&gt;
&lt;td&gt;- Single-core design &lt;br/&gt; - Enable/disable functions freely via config file &lt;br/&gt; - Easy porting for MCU&lt;/td&gt;
&lt;td&gt;- Microkernel-like concept &lt;br/&gt; - Kconfig customizable/expandable at compile time &lt;br/&gt; - Supports multi-core (SMP)&lt;/td&gt;
&lt;td&gt;- Microkernel + Modular &lt;br/&gt; - Expand via Packages &lt;br/&gt; - Default kernel is lightweight, fast boot speed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Scheduling Mechanism&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Preemptive multitasking &lt;br/&gt; - Priority scheduling &lt;br/&gt; - preemption-threshold reduces unnecessary preemption&lt;/td&gt;
&lt;td&gt;- Preemptive or cooperative multitasking &lt;br/&gt; - Time slicing optional &lt;br/&gt; - Task notification improves performance&lt;/td&gt;
&lt;td&gt;- Hybrid preemptive/cooperative &lt;br/&gt; - Supports task migration under multi-core &lt;br/&gt; - Flexible setting of time slice and preemption policy&lt;/td&gt;
&lt;td&gt;- Preemptive based on priority &lt;br/&gt; - Low switching overhead &lt;br/&gt; - Suitable for time-critical applications&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Interrupt Management&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Provides fast interrupt response &lt;br/&gt; - Can use IPC primitives in ISR &lt;br/&gt; - Suggests complex logic be placed in Thread&lt;/td&gt;
&lt;td&gt;- Complete interrupt priority setting specifications &lt;br/&gt; - Provides &amp;ldquo;FromISR&amp;rdquo; API to interact with kernel &lt;br/&gt; - Avoid high priority interrupts blocking RTOS services&lt;/td&gt;
&lt;td&gt;- Methods correspond to different architectures &lt;br/&gt; - Allows complex processing in the latter half of ISR &lt;br/&gt; - Supports &lt;code&gt;irq_offload&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;- Concise interrupt entry/exit &lt;br/&gt; - Can wake up tasks or IPC in ISR &lt;br/&gt; - Suggests handling heavy tasks after interrupt or in Task&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Task Communication &amp;amp; Sync&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Provides Semaphore, Mutex, Event Flags, Message Queue &lt;br/&gt; - Block Pool / Byte Pool as underlying resources&lt;/td&gt;
&lt;td&gt;- Has Queue, Semaphore, Mutex, Event Group, Task Notification &lt;br/&gt; - Queue is the core communication channel&lt;/td&gt;
&lt;td&gt;- Provides diverse mechanisms like Queue, FIFO, LIFO, Pipe, Mailbox, Semaphore, Mutex &lt;br/&gt; - High-level communication like Signals/Events&lt;/td&gt;
&lt;td&gt;- Provides Semaphore, Mutex, Event, Mailbox, Message Queue &lt;br/&gt; - Modular API, easy to expand&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Memory Management&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Block Pool (fixed size) &lt;br/&gt; - Byte Pool (flexible allocation) &lt;br/&gt; - Suitable for small systems&lt;/td&gt;
&lt;td&gt;- Multiple heap implementations (heap1~heap5) &lt;br/&gt; - Choose static or dynamic allocation based on needs &lt;br/&gt; - Must pay attention to allocating Semaphore / Mutex to ensure multi-task safety&lt;/td&gt;
&lt;td&gt;- Multiple allocation strategies like slab, mempool, heap &lt;br/&gt; - Fine-tuning via Kconfig &lt;br/&gt; - Requires good configuration at compile stage&lt;/td&gt;
&lt;td&gt;- Mempool, heap dichotomy &lt;br/&gt; - Default lightweight dynamic allocation algorithm &lt;br/&gt; - Can be paired with custom or high-level alloc algorithms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Debug &amp;amp; Trace&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Can use tools like TraceX &lt;br/&gt; - High integration, visualizing Thread, Event, IPC&lt;/td&gt;
&lt;td&gt;- FreeRTOS+Trace, many third-party IDE tracking tools &lt;br/&gt; - Deep integration with Percepio Tracealyzer&lt;/td&gt;
&lt;td&gt;- Unified Tracing subsystem &lt;br/&gt; - Can connect to Tracealyzer, LTTng, SystemView, etc. &lt;br/&gt; - Rich tracing support&lt;/td&gt;
&lt;td&gt;- RT-Thread Studio or other plugins &lt;br/&gt; - Provides simple log system and online debug mechanism &lt;br/&gt; - Community also has tracing solutions similar to FreeRTOS Trace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Portability &amp;amp; Scalability&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Officially supports most ARM, RISC-V, MIPS &lt;br/&gt; - Community gradually expanding after Microsoft acquisition&lt;/td&gt;
&lt;td&gt;- Ported to almost all MCUs &lt;br/&gt; - Large number of third-party packages and drivers &lt;br/&gt; - Can extend cloud functions via AWS FreeRTOS&lt;/td&gt;
&lt;td&gt;- Native support for many major hardware manufacturers (Intel, NXP, Nordic&amp;hellip;) &lt;br/&gt; - Kconfig + Devicetree similar to Linux &lt;br/&gt; - Corporate support and community equal weight&lt;/td&gt;
&lt;td&gt;- Widely used in Asia (especially China) &lt;br/&gt; - High integration with domestic MCUs, RISC-V platforms &lt;br/&gt; - Packages allow flexible function expansion&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="summary"&gt;Summary
&lt;/h2&gt;&lt;p&gt;Summarizing the four RTOS mentioned above:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;AzureRTOS (ThreadX)&lt;/strong&gt;: Known for high efficiency and small footprint, excels in executing in harsh resource-constrained environments, also has good debugging tools and business cases, good support for STM32.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FreeRTOS&lt;/strong&gt;: Has a huge open source community and flexible scalability, suitable for a wide range of microcontrollers and embedded applications, common in academic or commercial projects, suitable for beginners.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zephyr&lt;/strong&gt;: Strongly promoted by the Linux Foundation and multiple companies, extensive hardware support, and powerful tracking and analysis tools, suitable for medium to large embedded applications requiring high reliability and detailed monitoring.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RT-Thread&lt;/strong&gt;: Lightweight architecture, clear modularity, fast boot speed, suitable for IoT and other scenarios requiring high real-time performance and resource efficiency.&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Embedded on Hsing-Yu Shih</title><link>https://www.hugoshih.com/categories/embedded/</link><description>Recent content in Embedded on Hsing-Yu Shih</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 30 Oct 2025 21:48:32 +0800</lastBuildDate><atom:link href="https://www.hugoshih.com/categories/embedded/index.xml" rel="self" type="application/rss+xml"/><item><title>關於 Aligned Memory Allocation</title><link>https://www.hugoshih.com/p/%E9%97%9C%E6%96%BC-aligned-memory-allocation/</link><pubDate>Thu, 30 Oct 2025 21:48:32 +0800</pubDate><guid>https://www.hugoshih.com/p/%E9%97%9C%E6%96%BC-aligned-memory-allocation/</guid><description>&lt;img src="https://i.imgur.com/WVmjgMd.jpeg" alt="Featured image of post 關於 Aligned Memory Allocation" />&lt;h2 id="起源">起源
&lt;/h2>&lt;p>由於在這個東西上吃了大悶虧，至於是什麼虧就不細究了，總之是我當初在看到這東西的時候沒有認真摸透，就趁著這個機會好好還債了
我想要用一個超級白話的方式讓人快速可以理解，下次遇到這個議題再回來看就能快速回憶起來&lt;/p>
&lt;h2 id="什麼是-aligned-memory-allocation">什麼是 Aligned Memory Allocation？
&lt;/h2>&lt;p>設想一個情況，今天程式運行到一個地方，如果我需要一些額外的記憶體來儲存新的資料，在 C 語言中我們一定會用到 &lt;code>malloc()&lt;/code> 來跟系統要額外的記憶體空間&lt;/p>
&lt;p>舉個例子，我現在突然需要 32 bytes 的空間，所以我就使出 &lt;code>malloc()&lt;/code>，然後系統就翻啊翻找啊找，最後在記憶體中找到了 32 bytes 的空間，並把起始的記憶體位置傳回來。這個起始的位置可能很隨機，像是 &lt;code>0x08004321&lt;/code>，不過這也無傷大雅，總之我現在有了 32 bytes 空間，我現在想對他幹嘛就幹嘛。&lt;/p>
&lt;p>然而然而，在某些情況（至於是哪些情況後面再講），我們會希望我們得到的記憶體的起始位置是「對齊」的。那什麼叫做對齊呢？&lt;/p>
&lt;p>舉個例子，如果你用一些 Hex 檔案的預覽工具，你會看到左邊的起始位置很整齊以 32 bytes 間隔，像下面這樣：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">一般隨機分配 (未對齊):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x08004321 | Data...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ^ 起始位置很隨意
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">32-byte Alignment (對齊):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x08000000 | Data...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x08000020 | Data... &amp;lt;-- 0x20 就是 32
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x08000040 | Data... &amp;lt;-- 0x40 就是 64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ^ 起始位置都可以被 32 整除
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/hr8QdrG.jpeg"
loading="lazy"
alt="image"
>&lt;/p>
&lt;p>所謂的 &lt;strong>Aligned Memory Allocation&lt;/strong>，就是我在要新的記憶體空間時，想要拿到一個&lt;strong>起始位置可以被 32（或是其他數字）整除的記憶體空間&lt;/strong>&lt;/p>
&lt;p>OK，所以說到這邊應該對這個 Aligned Memory Allocation 是什麼應該有點概念了，這樣就成功了一半了。因為大多數人第一次聽到應該都比較難想到這是什麼，又或者知道這是什麼，但不知道有什麼用&lt;/p>
&lt;p>所以，這個有什麼用呢？&lt;/p>
&lt;h2 id="為什麼需要-alignment">為什麼需要 Alignment？
&lt;/h2>&lt;p>會需要 Alignment 大多是受到硬體設計的限制，例如：&lt;/p>
&lt;p>向量指令集 (如 AVX)，當執行這類指令集的時候，會要求目標的記憶體位置是對齊的，沒有對齊的話得要拆成兩步去處理，或是直接出現錯誤，那為什麼不設計成指令集可以讀取任意位置起始的記憶體呢？我覺得大多是成本考量，如果能從驅動程式端去解決，又何必浪費昂貴的硬體空間呢&lt;/p>
&lt;p>其他像是 CUDA 中 GPU 透過 PCIe 抓取資料時，使用 DMA 也會要求記憶體要對齊，又或者 GPU 指令抓取他自己記憶體的資料也會要求對齊，另外在 STM32 這類單晶片上使用 DMA 時，buffer 的記憶體位置也會要求對齊，才能夠被 DMA 正確寫入或讀取&lt;/p>
&lt;p>這時候一定有人跳出來說：「我平常用 CUDA 或是在 STM32 上用 DMA 都沒遇到這問題啊！」&lt;/p>
&lt;p>那是因為 CUDA driver 或是 HAL library 之類的會幫你處理好，所以當然沒感覺，反過來說，如果你今天寫的是 driver 或是 bare metal 開發，那一定要小心記憶體對齊這東西，不然可能連動都動不起來&lt;/p>
&lt;h2 id="所以該怎麼做到-alignment">所以該怎麼做到 Alignment？
&lt;/h2>&lt;p>前面說了這麼多，那要怎麼才能做到記憶體分配時 Alignment 呢？&lt;/p>
&lt;p>設想今天我們目標要一塊新的 64 bytes 記憶體，並且要求 32-byte 對齊。
如果今天 &lt;code>malloc&lt;/code> 給的起始位置剛剛好就是 &lt;code>0x08000040&lt;/code>，是 alignment block 的起始位置，這樣就中大獎了，但實際上當然不會那麼幸運，他可能給你的起始位置是 &lt;code>0x08000041&lt;/code>（偏移了 1 個 byte），也可能起始是 &lt;code>0x0800005F&lt;/code>（偏移了 31 個 bytes）&lt;/p>
&lt;p>但沒關係，這時候就會想到，只要&lt;code>malloc&lt;/code>的記憶體夠長，從中找到一個 Alignment Block 的起點並從那邊開始存資料，這樣也算對齊吧&lt;/p>
&lt;p>那麼問題就回到，我們該要多長的記憶體呢？
觀察前面的例子，如果做 32 bytes 的 alignment，偏移的量最多就是 &lt;code>0 ~ 31&lt;/code> bytes。所以我們要 &lt;code>malloc()&lt;/code> 的空間至少要是 &lt;code>size + alignment - 1&lt;/code>&lt;/p>
&lt;p>等等，好像少了什麼？
這樣的話要怎麼才能 &lt;code>free&lt;/code> 掉 alignment 起始位址前面的那些空間呢？我們需要紀錄&lt;strong>真正原本 &lt;code>malloc&lt;/code> 出來的起始位址&lt;/strong>，所以還需要再多一個位置去存這個指標，這個需要的空間是 &lt;code>sizeof(void*)&lt;/code>&lt;/p>
&lt;p>總結來說，我們真正要 &lt;code>malloc()&lt;/code> 的長度是：
&lt;code>size + alignment - 1 + sizeof(void*)&lt;/code>&lt;/p>
&lt;p>&lt;strong>記憶體結構示意圖：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">實際 malloc 得到的區塊 (Original)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">|
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">v
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+-------------+---------------------+-------------------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| padding ... | 原始指標 (Stored) | 使用者拿到的指標 (Aligned)|
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+-------------+---------------------+-------------------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ^ ^
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 這格存著 original 符合 32-byte 對齊
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 的地址 我們回傳這個地址
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然後我們只要找到這裡面 alignment 的起始位址，並且把「原始的起始位址」存在 alignment 起始的前一格。這樣在 &lt;code>free&lt;/code> memory 時，只要從 alignment 位址&lt;strong>往前找一格&lt;/strong>，就可以找到我們應該要釋放的記憶體起點。&lt;/p>
&lt;p>原理概念上就是這樣了，那麼就來看看要怎麼實作吧。&lt;/p>
&lt;h2 id="c-語言實作">C 語言實作
&lt;/h2>&lt;p>以下用 32-byte alignment 為例子，可以把 32 換成任意想要的正整數 alignment（通常是 2 的次方）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdint.h&amp;gt; // 為了使用 uintptr_t&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">aligned_malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 1. 計算需要的總空間：
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// size + (alignment - 1) 的調整空間 + 存放原始指標的空間
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">original&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">32&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">original&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 2. 算出 alignment 的起始位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 先預留一個 pointer 的空間給我們存地址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">uintptr_t&lt;/span> &lt;span class="n">raw&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uintptr_t&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">original&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 利用 Bitwise 操作進行對齊
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 原理：(address + mask) &amp;amp; ~mask
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 注意：這裡要用 ~(32 - 1) 也就是 ~31 才能遮掉後五位達到 32 對齊
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">uintptr_t&lt;/span> &lt;span class="n">aligned&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">raw&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">32&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 其實也可以用(void*)(original - (original % 32));去算
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 只是用bit manipulation感覺比較優雅
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 3. 把原本 malloc() 的起始位址存到 alignment 位址的前一格
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">aligned&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">original&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 4. 最後回傳 alignment 的起始
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">aligned&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">aligned_free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// free 的時候，去找到 alignment 位址前一格存的原來 malloc 的位址
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">original&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 然後把它釋放就行了
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">original&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="結語">結語
&lt;/h2>&lt;p>總之就是這樣，Aligned Memory Allocation這個東西重要又有一些實作小細節，藉由這個機會算是有搞懂他了，以後忘了也可以快速回來複習一下&lt;/p>
&lt;h2 id="reference">Reference
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://bclin.tw/2020/03/15/aligned-malloc/" target="_blank" rel="noopener"
>如何實作一個 aligned_alloc () ？&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://medium.com/howsofcoding/memory-management-aligned-malloc-and-free-9273336bd4c6" target="_blank" rel="noopener"
>Designing aligned Memory Allocator&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://linux.die.net/man/3/aligned_alloc" target="_blank" rel="noopener"
>aligned_alloc(3) - Linux man page&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>常見 Real-Time OS 介紹與比較</title><link>https://www.hugoshih.com/p/%E5%B8%B8%E8%A6%8B-real-time-os-%E4%BB%8B%E7%B4%B9%E8%88%87%E6%AF%94%E8%BC%83/</link><pubDate>Mon, 06 Jan 2025 15:32:31 +0800</pubDate><guid>https://www.hugoshih.com/p/%E5%B8%B8%E8%A6%8B-real-time-os-%E4%BB%8B%E7%B4%B9%E8%88%87%E6%AF%94%E8%BC%83/</guid><description>&lt;img src="https://i.imgur.com/7SJYZ3b.jpg" alt="Featured image of post 常見 Real-Time OS 介紹與比較" />&lt;h2 id="介紹">介紹
&lt;/h2>&lt;p>即時作業系統（Real-Time Operating System, RTOS）是一種專門為即時（real-time）應用而設計的作業系統，強調「在特定時間限制內（deadline）對事件進行回應」，試想一個情境在工業的領域若機器某部分突然產生故障，需要在極短的時間內停止所有馬達的運作，若此時使用的是傳統的作業系統如Linux，依OS內核的調度策略，最終馬達停止的動作會有些許延遲，相較之下RTOS則可以有較彈性的執行緒搶佔，讓緊急情況的處理可以更快被執行&lt;/p>
&lt;p>本質上來說RTOS的內核使用起來的效果是大同小異的，基本上能做到多個執行緒的建立、輪詢執行、優先序搶佔、互斥鎖、內核級的中斷等功能，進階一點的則有可以動態記憶體管理、多核心的支援，這些RTOS主要的差異大多是在外圍模組的支援、周邊的開發生態系等，以下就分別介紹目前主流常見的幾種RTOS:&lt;/p>
&lt;h3 id="freertoshttpsgithubcomfreertosfreertos">&lt;a class="link" href="https://github.com/FreeRTOS/FreeRTOS" target="_blank" rel="noopener"
>FreeRTOS&lt;/a>
&lt;/h3>&lt;p>FreeRTOS 是由 Real Time Engineers Ltd. 及 Amazon 維護，完全開源並且在全球廣受使用，FreeRTOS 可以說是最最最常見的一種RTOS，成功之道大概在於早早就開源，早早就被各家IDE整合，各家晶片的SDK也都可以看到他的影子，我最早接觸他是在Arduino IDE，FreeRTOS早早就出現在Arduino library list中，使用起來也夠簡單，沒有什麼複雜的設定，加一兩行code就可以實現多執行緒，讓初學者很容易就可以踏入RTOS的世界。他背後的金主爸爸是 Amazon，後來也整合了不少 AWS 上IoT相關的功能，由於早早就開源，周圍的模組也不少。&lt;/p>
&lt;h3 id="azurertos-threadxhttpsgithubcomeclipse-threadxthreadx">&lt;a class="link" href="https://github.com/eclipse-threadx/threadx" target="_blank" rel="noopener"
>AzureRTOS (Threadx)&lt;/a>
&lt;/h3>&lt;p>ThreadX 是由 Express Logic 開發的即時作業系統（RTOS），後續被 Microsoft 收購並推出更名版本 AzureRTOS 並開源，從名字就可以看出來未來應該是要跟微軟的 Azure 搭配做一些IoT的功能，但目前好像還沒看到什麼殺手級的應用。由於開源的時間比較晚，周圍的套件比較少，像BLE、Wifi這類的Stack能用的東西好像比較少，但相信有微軟原生的支援應該可以成長的很快，我會碰到 AzureRTOS 是因為 STM32 官方原生支援 AzureRTOS，很有趣的是 STM32 的開發環境也有支援 FreeRTOS，但支援度是遠遜於 AzureRTOS 的。&lt;/p>
&lt;h3 id="zephyrhttpsgithubcomzephyrproject-rtoszephyr">&lt;a class="link" href="https://github.com/zephyrproject-rtos/zephyr" target="_blank" rel="noopener"
>Zephyr&lt;/a>
&lt;/h3>&lt;p>Zephyr 是由 Linux 基金會（Linux Foundation）主導的開源即時作業系統（RTOS），Zephyr雖然出現很久了，但算是這幾年才突然紅起來，主打一個跨平台的相容性和完整的開發工具鏈，有像是West這種很好用的工具、也有像是DeviceTree者種為跨平台設計的架構，可以說要用Zephyr就要連著這一整串工具鏈一起用才會好用，不過好像也是因為綁著工具鏈跟相容性的原因，好像各家晶片雖然說有支援，但好像又支援的沒那麼好，特別是牽涉到很底層的硬體設定(像時鐘樹設定)就會變的特別麻煩，如果沒有這種需求就蠻好用的，很多設定、初始化都幫你省略了。會碰到Zephyr是因為使用 Nordic 的藍牙 SoC，最新的的 nrf connect SDK 基本上是建立在 Zephyr 上的，而 Zephyr 通訊相關的套件也很完整，很適合給 Nordic 的晶片用。&lt;/p>
&lt;h3 id="rt-threadhttpsgithubcomrt-threadrt-thread">&lt;a class="link" href="https://github.com/RT-Thread/rt-thread" target="_blank" rel="noopener"
>RT-Thread&lt;/a>
&lt;/h3>&lt;p>RT-Thread 是一款由中國團隊主導開發的開源即時作業系統（RTOS），在中國的嵌入式系統開源社群算蠻熱門的，對中國製MCU(特別是一些RISC-V的晶片)支援度很好，但其他地方就比較少看到有人在用，跟Zephyr一樣也有蠻多工具可以使用，我自己還沒有用過，但讓我印象深刻的是RT-Thread社群有一個可以一鍵生成 STM32 bootloader 的工具，不過要使用要註冊帳號，而且還限定用中國的電話才能註冊&amp;hellip;，就對中國以外的開發者不是很友好。&lt;/p>
&lt;h2 id="比較">比較
&lt;/h2>&lt;h3 id="幾種rtos的差別">幾種RTOS的差別
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>名稱&lt;/strong>&lt;/th>
&lt;th>&lt;strong>AzureRTOS (ThreadX)&lt;/strong>&lt;/th>
&lt;th>&lt;strong>FreeRTOS&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Zephyr&lt;/strong>&lt;/th>
&lt;th>&lt;strong>RT-Thread&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>維護者&lt;/strong>&lt;/td>
&lt;td>- 原為 Express Logic 開發，現由 Azure (Microsoft) 管理 &lt;br/> - 被微軟購買後開源&lt;/td>
&lt;td>- AWS（Amazon）及大社群共同維護 &lt;br/> - 開源專案，有廣大社群支援&lt;/td>
&lt;td>- 由 Linux Foundation 托管 &lt;br/> - 眾多主要產業贊助商與貢獻者（如 Intel、Nordic 等）&lt;/td>
&lt;td>- 中國嵌入式廠商與RT-Thread 社群&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>授權&lt;/strong>&lt;/td>
&lt;td>- MIT 授權 (開源版本)&lt;/td>
&lt;td>- MIT 授權 &lt;br/> - 完全開源、商業可使用&lt;/td>
&lt;td>- Apache 2.0 授權 &lt;br/> - 完全開源&lt;/td>
&lt;td>- LGPL 授權 &lt;br/> - 可商業使用，但需遵守 LGPL 條款&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>主要特色&lt;/strong>&lt;/td>
&lt;td>- 小巧的記憶體佔用 &lt;br/> - 高效能可搶先式多工 &lt;br/> - 整合除錯功能、其他外設控制模組&lt;/td>
&lt;td>- 模組化設計，可高度客製化內核 &lt;br/> - 協同式及可搶先式多工 &lt;br/> - 詳細文件與巨大社群，支援度高&lt;/td>
&lt;td>- 跨平台相容性好 &lt;br/> - 追蹤與分析工具完善 &lt;br/> - 與 Percepio Tracealyzer 整合&lt;/td>
&lt;td>- 輕量化設計與微核心架構 &lt;br/> - 效率高，啟動速度快 &lt;br/> - 著重模組化與易用性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>使用門檻&lt;/strong>&lt;/td>
&lt;td>- 門檻中 &lt;br/> - 提供專門的 API 與工具鏈 &lt;br/> - 原生支援STM32，其他晶片支援則較少&lt;/td>
&lt;td>- 門檻低 &lt;br/> - 文件全面且社群龐大 &lt;br/> - 新手上手相對容易，維護成本低&lt;/td>
&lt;td>- 門檻高 &lt;br/> - 須熟悉成套的開發工具鏈 &lt;br/> - 社群與企業資源豐富，難度取決於應用深度&lt;/td>
&lt;td>- 門檻中 &lt;br/> - 設計較為精簡易懂 &lt;br/> - 模組化讓功能可彈性擴充，但仍需對 RTOS 原理有基礎理解&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>社群與生態&lt;/strong>&lt;/td>
&lt;td>- 因 Microsoft Azure 加持，工業界支持度高 &lt;br/> - 開源時間較晚，社群支援相較少&lt;/td>
&lt;td>- 擁有極為廣泛的使用者社群 &lt;br/> - 豐富的第三方套件與論壇資源&lt;/td>
&lt;td>- 企業和開源社群雙管齊下 &lt;br/> - 大型廠商投入資源開發並提供硬體支援 &lt;br/> - 文件與套件工具逐漸成熟&lt;/td>
&lt;td>- 亞洲市場擁有極大用戶基礎 &lt;br/> - 社群不斷壯大，第三方資源也逐年提升&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>適用範圍&lt;/strong>&lt;/td>
&lt;td>- 消費電子、工業設備 &lt;br/> - 高度資源受限或需要高效能的應用&lt;/td>
&lt;td>- 廣泛用於各類微控制器與嵌入式裝置 &lt;br/> - 適合中小型專案或原型開發&lt;/td>
&lt;td>- 高度跨平台相容性的產品 &lt;br/> - 需要整合多種通訊協定的裝置&lt;/td>
&lt;td>- 小型物聯網裝置、家電產品、工業控制等 &lt;br/> - 適合資源有限且需高即時性的情境&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>範例&lt;/strong>&lt;/td>
&lt;td>- 高度整合 SoC 平台 &lt;br/> - 網路裝置、醫療器械、消費性電子設備 &lt;br/> - 資源特別有限但需穩定度的系統&lt;/td>
&lt;td>- 物聯網邊緣設備 &lt;br/> - 小型感測器、可攜式產品 &lt;br/> - 工業自動化控制&lt;/td>
&lt;td>- 高速通訊設備 &lt;br/> - 需要完整追蹤與調試能力的工業設備 &lt;br/> - 精密儀器及高可靠度應用&lt;/td>
&lt;td>- 嵌入式微控制器 &lt;br/> - 智能家居與可穿戴式裝置 &lt;br/> - 需要快速啟動、高效率排程的場景&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="內核功能層面的差異">內核功能層面的差異
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>名稱&lt;/strong>&lt;/th>
&lt;th>&lt;strong>AzureRTOS (ThreadX)&lt;/strong>&lt;/th>
&lt;th>&lt;strong>FreeRTOS&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Zephyr&lt;/strong>&lt;/th>
&lt;th>&lt;strong>RT-Thread&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>內核架構&lt;/strong>&lt;/td>
&lt;td>- 輕量級、模組化設計 &lt;br/> - 單核心即時系統 &lt;br/> - 提供 preemption-threshold&lt;/td>
&lt;td>- 單核心設計 &lt;br/> - 透過設定檔自由啟用/停用功能 &lt;br/> - 針對 MCU 移植方便&lt;/td>
&lt;td>- 類微核心（microkernel）概念 &lt;br/> - Kconfig 編譯時可裁剪/擴充 &lt;br/> - 可支援多核心 (SMP)&lt;/td>
&lt;td>- 微核心 + 模組化 &lt;br/> - 通過 Packages 擴充 &lt;br/> - 預設核心輕量、啟動速度快&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>排程機制&lt;/strong>&lt;/td>
&lt;td>- 可搶先式多工 &lt;br/> - 優先順序排程 &lt;br/> - preemption-threshold 降低不必要的搶先&lt;/td>
&lt;td>- 可搶先式或協同式多工 &lt;br/> - 時間片 (time slicing) 可選 &lt;br/> - 任務通知提高效能&lt;/td>
&lt;td>- 可搶先式/協同式混合 &lt;br/> - 支援多核心下的任務搬移 &lt;br/> - 彈性設定時間片與搶先策略&lt;/td>
&lt;td>- 以優先順序為基礎的可搶先式 &lt;br/> - 切換開銷低 &lt;br/> - 適合時限嚴苛的應用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>中斷管理&lt;/strong>&lt;/td>
&lt;td>- 提供快速中斷響應 &lt;br/> - ISR 中可使用 IPC 原語 &lt;br/> - 建議複雜邏輯放在 Thread&lt;/td>
&lt;td>- 有完整的中斷優先級設定規範 &lt;br/> - 提供「FromISR」API 與核心互動 &lt;br/> - 避免高優先級中斷封鎖 RTOS 服務&lt;/td>
&lt;td>- 針對不同架構有對應方法 &lt;br/> - 允許在 ISR 後半段做較複雜處理 &lt;br/> - 支援 &lt;code>irq_offload&lt;/code>&lt;/td>
&lt;td>- 中斷入口/出口簡潔 &lt;br/> - 可在 ISR 裡做任務喚醒或 IPC &lt;br/> - 建議將重任務放在中斷後處理或 Task&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>任務通訊與同步&lt;/strong>&lt;/td>
&lt;td>- 提供 Semaphore、Mutex、Event Flags、Message Queue &lt;br/> - Block Pool / Byte Pool 作為底層資源&lt;/td>
&lt;td>- 有 Queue、Semaphore、Mutex、Event Group、Task Notification &lt;br/> - Queue 是核心溝通管道&lt;/td>
&lt;td>- 提供 Queue、FIFO、LIFO、Pipe、Mailbox、Semaphore、Mutex 等多樣化機制 &lt;br/> - 信號（Signals）/事件等高階通訊&lt;/td>
&lt;td>- 提供 Semaphore、Mutex、Event、Mailbox、Message Queue &lt;br/> - 模組化 API，易於擴充&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>記憶體管理&lt;/strong>&lt;/td>
&lt;td>- Block Pool（固定大小） &lt;br/> - Byte Pool（彈性分配） &lt;br/> - 適合小型系統&lt;/td>
&lt;td>- 多種 heap 實作 (heap1~heap5) &lt;br/> - 依需求選擇靜態或動態配置 &lt;br/> - 須注意配置 Semaphore / Mutex 以確保多任務安全&lt;/td>
&lt;td>- slab、mempool、heap 等多種分配策略 &lt;br/> - Kconfig 可細調 &lt;br/> - 需在編譯階段做良好配置&lt;/td>
&lt;td>- mempool、heap 二分法 &lt;br/> - 預設輕量動態分配算法 &lt;br/> - 可搭配自訂或高階 alloc 演算法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>除錯與追蹤&lt;/strong>&lt;/td>
&lt;td>- 可使用 TraceX 等工具 &lt;br/> - 整合度高，針對 Thread、Event、IPC 做可視化&lt;/td>
&lt;td>- FreeRTOS+Trace、第三方 IDE 追蹤工具多 &lt;br/> - 與 Percepio Tracealyzer 深度整合&lt;/td>
&lt;td>- 統一的 Tracing 子系統 &lt;br/> - 可連接 Tracealyzer、LTTng、SystemView 等 &lt;br/> - 追蹤支援度豐富&lt;/td>
&lt;td>- RT-Thread Studio 或其他插件 &lt;br/> - 提供簡單 log 系統與線上除錯機制 &lt;br/> - 社群亦有類似 FreeRTOS Trace 的追蹤方案&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>可移植性與擴充性&lt;/strong>&lt;/td>
&lt;td>- 官方主要支援多數 ARM、RISC-V、MIPS &lt;br/> - Microsoft 收購後社群逐漸擴大&lt;/td>
&lt;td>- 幾乎所有 MCU 都有移植 &lt;br/> - 大量第三方套件與驅動 &lt;br/> - 可透過 AWS FreeRTOS 延伸雲端功能&lt;/td>
&lt;td>- 原生支援多家大廠硬體 (Intel、NXP、Nordic&amp;hellip;) &lt;br/> - Kconfig + Devicetree 與 Linux 類似 &lt;br/> - 企業支援與社群並重&lt;/td>
&lt;td>- 在亞洲（特別是中國）用得廣泛 &lt;br/> - 與國產 MCU、RISC-V 平台整合度高 &lt;br/> - Packages 方式讓功能彈性擴充&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="總結">總結
&lt;/h2>&lt;p>總結一下前面提到的四種RTOS：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>AzureRTOS (ThreadX)&lt;/strong>：以高效能與小巧佔用聞名，擅長在嚴苛的資源受限環境中執行，另有良好的除錯工具與商業案例，對STM32的支援度好。&lt;/li>
&lt;li>&lt;strong>FreeRTOS&lt;/strong>：擁有巨大開源社群與靈活的擴充性，適用於廣泛的微控制器與嵌入式應用，在學術或商業專案皆常見，初學者適合。&lt;/li>
&lt;li>&lt;strong>Zephyr&lt;/strong>：受到 Linux 基金會與多家企業的大力推動，硬體支援廣泛，並有強大的追蹤與分析工具，適合需要高可靠度及詳細監控的中大型嵌入式應用&lt;/li>
&lt;li>&lt;strong>RT-Thread&lt;/strong>：架構輕量化、模組化明確，啟動速度快，適合物聯網及其他對即時性與資源效率要求高的場景。&lt;/li>
&lt;/ol></description></item><item><title>Zephyr RTOS 兩種建立Thread的方式</title><link>https://www.hugoshih.com/p/zephyr-rtos-%E5%85%A9%E7%A8%AE%E5%BB%BA%E7%AB%8Bthread%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Sun, 05 Jan 2025 22:20:31 +0800</pubDate><guid>https://www.hugoshih.com/p/zephyr-rtos-%E5%85%A9%E7%A8%AE%E5%BB%BA%E7%AB%8Bthread%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description>&lt;img src="https://i.imgur.com/V5OSNcL.jpg" alt="Featured image of post Zephyr RTOS 兩種建立Thread的方式" />&lt;h1 id="zephyr-rtos-兩種建立thread的方式">Zephyr RTOS 兩種建立Thread的方式
&lt;/h1>&lt;h2 id="thread-執行緒">Thread (執行緒)
&lt;/h2>&lt;p>在 Zephyr OS中，每個獨立的功能或任務可以放在不同的執行緒中執行，內部使用了輕量級的排程器，可以根據不同執行緒的優先級，以及執行緒本身的狀態（ready, running, pending 等），來決定哪一個執行緒能夠先被 CPU 執行，執行緒可以有以下幾個性質：&lt;/p>
&lt;ol>
&lt;li>執行緒優先級（Priority）：數值越小表示優先級越高（Preemptive scheduling 的情況下）。&lt;/li>
&lt;li>堆疊大小（Stack Size）：每個執行緒必須設定自己的堆疊空間，Zephyr 會在執行緒切換時儲存或恢復執行緒的上下文。&lt;/li>
&lt;li>執行緒生命週期（Lifecycle）：可以在編譯期就被預先配置好，或在執行期動態配置與建立。&lt;/li>
&lt;/ol>
&lt;h2 id="zephyr-建立執行緒的兩種常見方法">Zephyr 建立執行緒的兩種常見方法
&lt;/h2>&lt;h3 id="在編譯期間compile-time建立執行緒">在編譯期間（Compile Time）建立執行緒
&lt;/h3>&lt;p>Zephyr 提供了一個巨集 &lt;code>K_THREAD_DEFINE()&lt;/code> 用於在編譯期就宣告並建立執行緒。只要程式一開啟並初始化 RTOS 後，這些執行緒就會自動被建立並進入排程器的管理。&lt;/p>
&lt;h4 id="k_thread_define">K_THREAD_DEFINE()
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define K_THREAD_DEFINE(name, stack_size, entry_fn, p1, p2, p3, \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"> prio, options, delay)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>name：此執行緒的識別名稱，同時會生成一個 k_tid_t 型態的變數。&lt;/li>
&lt;li>stack_size：此執行緒的堆疊大小（以 byte 為單位）。&lt;/li>
&lt;li>entry_fn：此執行緒進入點函式（thread function），開始執行時要跑哪個函式。&lt;/li>
&lt;li>p1, p2, p3：最多可傳入三個參數給進入點函式使用（都為 void* 型態）。&lt;/li>
&lt;li>prio：優先級（數值越小，優先級越高）。&lt;/li>
&lt;li>options：執行緒選項，通常先給 0 表示沒有特別的額外設定。&lt;/li>
&lt;li>delay：執行緒開始之前的延遲時間（ticks 或毫秒），若填 0 表示不延遲，立即就緒。&lt;/li>
&lt;/ul>
&lt;h3 id="在執行期間run-time建立執行緒">在執行期間（Run Time）建立執行緒
&lt;/h3>&lt;p>另一種是在程式運行期間建立執行緒，使用 API 函數&lt;code>k_thread_create()&lt;/code> 建立執行緒。這種方法在有些情況下會更具彈性，例如依據狀態或條件，動態啟動或終止執行緒，以免靜態建立過多浪費資源。&lt;/p>
&lt;h4 id="k_thread_create">k_thread_create()
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">k_tid_t&lt;/span> &lt;span class="nf">k_thread_create&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">k_thread&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">new_thread&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">k_thread_stack_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">stack_size&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">k_thread_entry_t&lt;/span> &lt;span class="n">entry&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">prio&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">k_timeout_t&lt;/span> &lt;span class="n">delay&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>new_thread：指向使用者自行宣告的 struct k_thread 物件，用來儲存此執行緒的控制區塊。&lt;/li>
&lt;li>stack：指向此執行緒對應的堆疊空間（需先以 &lt;code>K_THREAD_STACK_DEFINE()&lt;/code> 靜態或動態配置）。&lt;/li>
&lt;li>stack_size：此堆疊的大小。&lt;/li>
&lt;li>entry：執行緒執行的進入點函式。&lt;/li>
&lt;li>p1, p2, p3：最多可傳入三個參數到執行緒函式。&lt;/li>
&lt;li>prio：優先級。&lt;/li>
&lt;li>options：執行緒選項，常用為 0。&lt;/li>
&lt;li>delay：執行緒開始前是否要延遲。&lt;/li>
&lt;/ul>
&lt;h2 id="範例">範例
&lt;/h2>&lt;p>以下兩段程式碼，分別示範用 &lt;code>K_THREAD_DEFINE()&lt;/code>（在編譯期間）或 &lt;code>k_thread_create()&lt;/code>（在執行期間）建立兩個執行緒，分別執行 LED 漸亮漸暗（fade_led） 與 LED 閃爍（toggle_led） 的功能
&lt;a class="link" href="https://github.com/h920032/Zephyr-blinky-toggle-demo" target="_blank" rel="noopener"
>github repo&lt;/a>
以下是在Nucleo-F303K8的執行結果，左邊LED執行toggle，右邊執行fading
&lt;img src="https://imgur.com/V0jJ9bs.gif"
loading="lazy"
>&lt;/p>
&lt;h3 id="在編譯期間compile-time動態建立執行緒範例">在編譯期間（Compile Time）動態建立執行緒範例
&lt;/h3>&lt;ol>
&lt;li>&lt;code>K_THREAD_DEFINE(fade_tid, 512, fade_led, NULL, NULL, NULL, 5, 0, 0);&lt;/code>
&lt;ul>
&lt;li>建立一個名為 fade_tid 的執行緒，堆疊大小 512 bytes，執行函式為 fade_led，優先級 5。&lt;/li>
&lt;li>p1, p2, p3 都填 NULL，表示不需要傳遞參數。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>K_THREAD_DEFINE(toggle_tid, 512, toggle_led, NULL, NULL, NULL, 5, 0, 0);&lt;/code>
&lt;ul>
&lt;li>同樣建立名為 toggle_tid 的執行緒，stack大小、優先級參數與上面一致，執行函式為 toggle_led。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>這些執行緒在編譯的時候就已經被「靜態配置」了，所以當系統啟動並執行到 main() 時，它們也就由排程器自動啟動並不斷執行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/kernel.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/sys/printk.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/device.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/drivers/pwm.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/drivers/gpio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">fade_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">toggle_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 利用 DT_ALIAS(pwm_led0) 與 DT_ALIAS(led1) 取得裝置樹中的設備訊息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">pwm_dt_spec&lt;/span> &lt;span class="n">pwm_led0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">PWM_DT_SPEC_GET&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">DT_ALIAS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">gpio_dt_spec&lt;/span> &lt;span class="n">led1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">GPIO_DT_SPEC_GET&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">DT_ALIAS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">led1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">gpios&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 這裡定義一些常數用於控制漸亮漸暗的速度或節拍
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#define NUM_STEPS 256U
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define SLEEP_MSEC 5U
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define SLEEP_TIME_MS 500
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 在編譯期間靜態建立兩個執行緒
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">K_THREAD_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fade_tid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fade_led&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">K_THREAD_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">toggle_tid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">toggle_led&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// fade_led 會透過 PWM 設定脈寬來控制 LED 的亮度，製造 &amp;#34;呼吸燈&amp;#34; 效果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">fade_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">step&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">period&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">NUM_STEPS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint8_t&lt;/span> &lt;span class="n">dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 設定當前的脈寬
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pwm_set_pulse_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pulse_width&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 調整脈寬，控制 LED 往漸亮或漸暗方向
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">dir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pulse_width&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">period&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">period&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pulse_width&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">k_sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">K_MSEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SLEEP_MSEC&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// toggle_led 會透過 GPIO pin toggle 的方式，使 LED 閃爍
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">toggle_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">gpio_pin_toggle_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">led1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">k_sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">K_MSEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SLEEP_TIME_MS&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 檢查 PWM 裝置是否 ready
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">pwm_is_ready_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Error: PWM device %s is not ready&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 設定 GPIO pin 為輸出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">gpio_pin_configure_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">led1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO_OUTPUT_ACTIVE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// main 函式結束後，兩個 K_THREAD_DEFINE 建立的執行緒依然會持續執行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="在執行期run-time動態建立執行緒範例">在執行期（Run Time）動態建立執行緒範例
&lt;/h3>&lt;p>若想要在程式執行的過程中（例如：由某個事件觸發）再建立執行緒，可以使用以下的做法：
1. 用 &lt;code>K_THREAD_STACK_DEFINE(my_stack_area, STACK_SIZE)&lt;/code>; 定義stack。
2. 定義一個 struct k_thread my_thread_data; 作為執行緒控制區塊（Thread Control Block, TCB）。
3. 呼叫 k_thread_create()，傳入上述的stack、控制區塊、進入點函式及其他參數來完成建立。&lt;/p>
&lt;p>以下是一個範例，展示如何在 main() 函式中動態建立執行緒（此示例僅顯示與執行緒有關的部分，省略週邊初始化等重複程式碼）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">前面的程式碼相同&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">*&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 宣告執行緒stack size
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="nf">K_THREAD_STACK_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fade_stack&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="nf">K_THREAD_STACK_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">toggle_stack&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 宣告執行緒控制區塊
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">k_thread&lt;/span> &lt;span class="n">fade_thread_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">k_thread&lt;/span> &lt;span class="n">toggle_thread_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 這兩個函式和之前範例雷同
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">fade_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">toggle_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在執行期動態建立 fade_led thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">k_tid_t&lt;/span> &lt;span class="n">fade_tid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">k_thread_create&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">fade_thread_data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">my_fade_stack&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">K_THREAD_STACK_SIZEOF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_fade_stack&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fade_led&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">K_NO_WAIT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在執行期動態建立 toggle_led thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">k_tid_t&lt;/span> &lt;span class="n">toggle_tid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">k_thread_create&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">toggle_thread_data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">my_toggle_stack&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">K_THREAD_STACK_SIZEOF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_toggle_stack&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">toggle_led&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">K_NO_WAIT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// k_thread_create 回傳 k_tid_t，可用於後續管理 thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 例如 k_thread_suspend(fade_tid), k_thread_resume(fade_tid), k_thread_abort(fade_tid)...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="比較">比較
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>建立方式&lt;/th>
&lt;th>特點&lt;/th>
&lt;th>典型使用時機&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Compile Time 建立&lt;/td>
&lt;td>&lt;code>K_THREAD_DEFINE()&lt;/code>&lt;/td>
&lt;td>一開始已知需要的執行緒，以及系統資源充足時&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Run Time 動態建立&lt;/td>
&lt;td>&lt;code>k_thread_create()&lt;/code>，在程式執行時期再分配資源&lt;/td>
&lt;td>不確定需要多少執行緒，或需要彈性創建／釋放&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>如果確定在整個系統的生命週期中，執行緒數量固定，或是系統比較單純（例如一個簡單的多任務控制），用編譯期方式能減少程式碼的複雜度，也能讓程式一啟動就快速就緒。&lt;/li>
&lt;li>如果系統中會動態產生／取消某些任務（如：偵測到新裝置才開新任務等），就可以使用動態建立的方式，提高系統彈性。&lt;/li>
&lt;/ol>
&lt;h2 id="總結">總結
&lt;/h2>&lt;ul>
&lt;li>靜態（編譯期）建立執行緒：
&lt;ul>
&lt;li>使用 &lt;code>K_THREAD_DEFINE()&lt;/code>&lt;/li>
&lt;li>簡單、快速、程式架構清晰&lt;/li>
&lt;li>適用於固定且少數的長期執行緒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>動態（執行期）建立執行緒：
&lt;ul>
&lt;li>使用 &lt;code>k_thread_create()&lt;/code>&lt;/li>
&lt;li>需要自行管理堆疊、控制區塊等&lt;/li>
&lt;li>適用於需要彈性創建和銷毀大量或不定數量執行緒的應用場景&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>嵌入式系統常用的幾種MCU</title><link>https://www.hugoshih.com/p/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%B5%B1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%BE%E7%A8%AEmcu/</link><pubDate>Mon, 21 Aug 2023 19:32:31 +0800</pubDate><guid>https://www.hugoshih.com/p/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%B5%B1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%BE%E7%A8%AEmcu/</guid><description>&lt;img src="https://i.imgur.com/xEqWwbo.jpg" alt="Featured image of post 嵌入式系統常用的幾種MCU" />&lt;h1 id="嵌入式系統常用的幾種mcu">嵌入式系統常用的幾種MCU
&lt;/h1>&lt;p>最近在實作嵌入式系統時因為系統需要更強的運算功能，決定捨棄原本常用的Atmega328p，尋找其他32位元MCU開發平台，選擇平台是件大事，每個平台的適用場景跟開發環境都不同，藉此機會來分析一下。&lt;/p>
&lt;h2 id="atmel系列-如atmega328p">ATMEL系列 (如ATMEGA328P)
&lt;/h2>&lt;ul>
&lt;li>Atmega328p是ATMEL公司(美國)生產的8位元AVR架構MCU，常用於Arduino UNO板上&lt;/li>
&lt;li>優點:容易入門且文檔完整、社群支援完整(Arduino生態系建立的很好)、良好的功耗效率(這點沒實測過但聽說很不錯)&lt;/li>
&lt;li>缺點:與其他32位元MCU相比，處理能力有限、較少的內置記憶體和RAM、以他的性能來說小貴(35元上下)&lt;/li>
&lt;li>適用場景: 初學者入門的專案(例如Arduino教學、簡單的嵌入式專案)、低功耗低成本的家用電子裝置&lt;/li>
&lt;/ul>
&lt;h2 id="esp系列-如esp32-c3">ESP系列 (如ESP32-C3)
&lt;/h2>&lt;ul>
&lt;li>ESP32-C3是Espressif Systems公司(中國)的產品，基於32位元RICS-V或Xtensa架構，自帶WiFi和藍牙功能&lt;/li>
&lt;li>優點:直接包含WiFi和藍牙不用外接模組所以CP很高(一顆35-50元)、也是很多人在使用社群支援算完整、有內涵SPI flash的版本很方便&lt;/li>
&lt;li>缺點:較高的功耗(雖然有深度睡眠功能)、系統穩定性聽說不佳&lt;/li>
&lt;li>適用場景: IoT (物聯網) 需要WiFi或藍牙連接的設備、智慧家電、智慧穿戴裝置、不是很關鍵的東西。&lt;/li>
&lt;/ul>
&lt;h2 id="stm系列-如stmf103c8t6">STM系列 (如STMF103C8T6)
&lt;/h2>&lt;ul>
&lt;li>STMF103C8T6是STMicroelectronics公司(瑞士)的32位元ARM Cortex-M3微控制器&lt;/li>
&lt;li>優點:運算功能強、具有多種接口、有低功耗模式的版本，具有較高的性價比(範圍大20-60元都有)、有很完整的開發除錯工具、在工業產品中比較常用&lt;/li>
&lt;li>缺點:開發環境較為複雜、較少的RAM和Flash&lt;/li>
&lt;li>適用場景: 複雜的嵌入式專案、需要強大的處理能力、工業自動化、無人機、高階的感測器系統&lt;/li>
&lt;/ul>
&lt;h2 id="stc系列-如stc89c52">STC系列 (如STC89C52)
&lt;/h2>&lt;ul>
&lt;li>STC89C52是STC Micro公司(中國)生產的8位元8051微控制器。&lt;/li>
&lt;li>優點: 8051架構非常的古老、具有廣泛的應用和大量的資料支援、價格超便宜(10-50元)、開發環境算簡單。&lt;/li>
&lt;li>缺點:超舊的架構，處理能力有限、較少的內存和RAM、可以看作是人弱化版的Atmel系列、但因為功能單純，家電之類的很常用到&lt;/li>
&lt;li>適用場景: 傳統的嵌入式系統，如家用電器控制、教育用途，學習8051微控制器的原理和程式設計、簡單的LED顯示、鍵盤輸入等基本IO操作&lt;/li>
&lt;/ul>
&lt;h2 id="raspberry系列-如rp2040">RASPBERRY系列 (如RP2040)
&lt;/h2>&lt;ul>
&lt;li>RP2040是Raspberry Pi基金會(英國)開發的32位元ARM Cortex-M0+微控制器&lt;/li>
&lt;li>優點:高效的處理性能、RAM算大、開源資源和社群支援、簡單的開發環境(Micropython)、CP值也很高(35元)&lt;/li>
&lt;li>缺點: 較新的產品，可能存在與硬體不穩定的問題有些Bug可能還沒有解法&lt;/li>
&lt;li>適用場景: 要求高性能處理的嵌入式專案、影音運算、影像處理、複雜的演算法運算、大數據處理、跑TinyML模型等等&lt;/li>
&lt;/ul></description></item></channel></rss>
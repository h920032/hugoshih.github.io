<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RTOS on Hsing-Yu Shih</title><link>https://www.hugoshih.com/tags/rtos/</link><description>Recent content in RTOS on Hsing-Yu Shih</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 06 Jan 2025 15:32:31 +0800</lastBuildDate><atom:link href="https://www.hugoshih.com/tags/rtos/index.xml" rel="self" type="application/rss+xml"/><item><title>常見RTOS比較</title><link>https://www.hugoshih.com/p/%E5%B8%B8%E8%A6%8Brtos%E6%AF%94%E8%BC%83/</link><pubDate>Mon, 06 Jan 2025 15:32:31 +0800</pubDate><guid>https://www.hugoshih.com/p/%E5%B8%B8%E8%A6%8Brtos%E6%AF%94%E8%BC%83/</guid><description>&lt;img src="https://i.imgur.com/7SJYZ3b.jpg" alt="Featured image of post 常見RTOS比較" />&lt;h2 id="介紹">介紹
&lt;/h2>&lt;p>即時作業系統（Real-Time Operating System, RTOS）是一種專門為即時（real-time）應用而設計的作業系統，強調「在特定時間限制內（deadline）對事件進行回應」，試想一個情境在工業的領域若機器某部分突然產生故障，需要在極短的時間內停止所有馬達的運作，若此時使用的是傳統的作業系統如Linux，依OS內核的調度策略，最終馬達停止的動作會有些許延遲，相較之下RTOS則可以有較彈性的執行緒搶佔，讓緊急情況的處理可以更快被執行&lt;/p>
&lt;p>本質上來說RTOS的內核使用起來的效果是大同小異的，基本上能做到多個執行緒的建立、輪詢執行、優先序搶佔、互斥鎖、內核級的中斷等功能，進階一點的則有可以動態記憶體管理、多核心的支援，這些RTOS主要的差異大多是在外圍模組的支援、周邊的開發生態系等，以下就分別介紹目前主流常見的幾種RTOS:&lt;/p>
&lt;h3 id="freertoshttpsgithubcomfreertosfreertos">&lt;a class="link" href="https://github.com/FreeRTOS/FreeRTOS" target="_blank" rel="noopener"
>FreeRTOS&lt;/a>
&lt;/h3>&lt;p>FreeRTOS 是由 Real Time Engineers Ltd. 及 Amazon 維護，完全開源並且在全球廣受使用，FreeRTOS 可以說是最最最常見的一種RTOS，成功之道大概在於早早就開源，早早就被各家IDE整合，各家晶片的SDK也都可以看到他的影子，我最早接觸他是在Arduino IDE，FreeRTOS早早就出現在Arduino library list中，使用起來也夠簡單，沒有什麼複雜的設定，加一兩行code就可以實現多執行緒，讓初學者很容易就可以踏入RTOS的世界。他背後的金主爸爸是 Amazon，後來也整合了不少 AWS 上IoT相關的功能，由於早早就開源，周圍的模組也不少。&lt;/p>
&lt;h3 id="azurertos-threadxhttpsgithubcomeclipse-threadxthreadx">&lt;a class="link" href="https://github.com/eclipse-threadx/threadx" target="_blank" rel="noopener"
>AzureRTOS (Threadx)&lt;/a>
&lt;/h3>&lt;p>ThreadX 是由 Express Logic 開發的即時作業系統（RTOS），後續被 Microsoft 收購並推出更名版本 AzureRTOS 並開源，從名字就可以看出來未來應該是要跟微軟的 Azure 搭配做一些IoT的功能，但目前好像還沒看到什麼殺手級的應用。由於開源的時間比較晚，周圍的套件比較少，像BLE、Wifi這類的Stack能用的東西好像比較少，但相信有微軟原生的支援應該可以成長的很快，我會碰到 AzureRTOS 是因為 STM32 官方原生支援 AzureRTOS，很有趣的是 STM32 的開發環境也有支援 FreeRTOS，但支援度是遠遜於 AzureRTOS 的。&lt;/p>
&lt;h3 id="zephyrhttpsgithubcomzephyrproject-rtoszephyr">&lt;a class="link" href="https://github.com/zephyrproject-rtos/zephyr" target="_blank" rel="noopener"
>Zephyr&lt;/a>
&lt;/h3>&lt;p>Zephyr 是由 Linux 基金會（Linux Foundation）主導的開源即時作業系統（RTOS），Zephyr雖然出現很久了，但算是這幾年才突然紅起來，主打一個跨平台的相容性和完整的開發工具鏈，有像是West這種很好用的工具、也有像是DeviceTree者種為跨平台設計的架構，可以說要用Zephyr就要連著這一整串工具鏈一起用才會好用，不過好像也是因為綁著工具鏈跟相容性的原因，好像各家晶片雖然說有支援，但好像又支援的沒那麼好，特別是牽涉到很底層的硬體設定(像時鐘樹設定)就會變的特別麻煩，如果沒有這種需求就蠻好用的，很多設定、初始化都幫你省略了。會碰到Zephyr是因為使用 Nordic 的藍牙 SoC，最新的的 nrf connect SDK 基本上是建立在 Zephyr 上的，而 Zephyr 通訊相關的套件也很完整，很適合給 Nordic 的晶片用。&lt;/p>
&lt;h3 id="rt-threadhttpsgithubcomrt-threadrt-thread">&lt;a class="link" href="https://github.com/RT-Thread/rt-thread" target="_blank" rel="noopener"
>RT-Thread&lt;/a>
&lt;/h3>&lt;p>RT-Thread 是一款由中國團隊主導開發的開源即時作業系統（RTOS），在中國的嵌入式系統開源社群算蠻熱門的，對中國製MCU(特別是一些RISC-V的晶片)支援度很好，但其他地方就比較少看到有人在用，跟Zephyr一樣也有蠻多工具可以使用，我自己還沒有用過，但讓我印象深刻的是RT-Thread社群有一個可以一鍵生成 STM32 bootloader 的工具，不過要使用要註冊帳號，而且還限定用中國的電話才能註冊&amp;hellip;，就對中國以外的開發者不是很友好。&lt;/p>
&lt;h2 id="比較">比較
&lt;/h2>&lt;h3 id="幾種rtos的差別">幾種RTOS的差別
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>名稱&lt;/strong>&lt;/th>
&lt;th>&lt;strong>AzureRTOS (ThreadX)&lt;/strong>&lt;/th>
&lt;th>&lt;strong>FreeRTOS&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Zephyr&lt;/strong>&lt;/th>
&lt;th>&lt;strong>RT-Thread&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>維護者&lt;/strong>&lt;/td>
&lt;td>- 原為 Express Logic 開發，現由 Azure (Microsoft) 管理 &lt;br/> - 被微軟購買後開源&lt;/td>
&lt;td>- AWS（Amazon）及大社群共同維護 &lt;br/> - 開源專案，有廣大社群支援&lt;/td>
&lt;td>- 由 Linux Foundation 托管 &lt;br/> - 眾多主要產業贊助商與貢獻者（如 Intel、Nordic 等）&lt;/td>
&lt;td>- 中國嵌入式廠商與RT-Thread 社群&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>授權&lt;/strong>&lt;/td>
&lt;td>- MIT 授權 (開源版本)&lt;/td>
&lt;td>- MIT 授權 &lt;br/> - 完全開源、商業可使用&lt;/td>
&lt;td>- Apache 2.0 授權 &lt;br/> - 完全開源&lt;/td>
&lt;td>- LGPL 授權 &lt;br/> - 可商業使用，但需遵守 LGPL 條款&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>主要特色&lt;/strong>&lt;/td>
&lt;td>- 小巧的記憶體佔用 &lt;br/> - 高效能可搶先式多工 &lt;br/> - 整合除錯功能、其他外設控制模組&lt;/td>
&lt;td>- 模組化設計，可高度客製化內核 &lt;br/> - 協同式及可搶先式多工 &lt;br/> - 詳細文件與巨大社群，支援度高&lt;/td>
&lt;td>- 跨平台相容性好 &lt;br/> - 追蹤與分析工具完善 &lt;br/> - 與 Percepio Tracealyzer 整合&lt;/td>
&lt;td>- 輕量化設計與微核心架構 &lt;br/> - 效率高，啟動速度快 &lt;br/> - 著重模組化與易用性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>使用門檻&lt;/strong>&lt;/td>
&lt;td>- 門檻中 &lt;br/> - 提供專門的 API 與工具鏈 &lt;br/> - 原生支援STM32，其他晶片支援則較少&lt;/td>
&lt;td>- 門檻低 &lt;br/> - 文件全面且社群龐大 &lt;br/> - 新手上手相對容易，維護成本低&lt;/td>
&lt;td>- 門檻高 &lt;br/> - 須熟悉成套的開發工具鏈 &lt;br/> - 社群與企業資源豐富，難度取決於應用深度&lt;/td>
&lt;td>- 門檻中 &lt;br/> - 設計較為精簡易懂 &lt;br/> - 模組化讓功能可彈性擴充，但仍需對 RTOS 原理有基礎理解&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>社群與生態&lt;/strong>&lt;/td>
&lt;td>- 因 Microsoft Azure 加持，工業界支持度高 &lt;br/> - 開源時間較晚，社群支援相較少&lt;/td>
&lt;td>- 擁有極為廣泛的使用者社群 &lt;br/> - 豐富的第三方套件與論壇資源&lt;/td>
&lt;td>- 企業和開源社群雙管齊下 &lt;br/> - 大型廠商投入資源開發並提供硬體支援 &lt;br/> - 文件與套件工具逐漸成熟&lt;/td>
&lt;td>- 亞洲市場擁有極大用戶基礎 &lt;br/> - 社群不斷壯大，第三方資源也逐年提升&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>適用範圍&lt;/strong>&lt;/td>
&lt;td>- 消費電子、工業設備 &lt;br/> - 高度資源受限或需要高效能的應用&lt;/td>
&lt;td>- 廣泛用於各類微控制器與嵌入式裝置 &lt;br/> - 適合中小型專案或原型開發&lt;/td>
&lt;td>- 高度跨平台相容性的產品 &lt;br/> - 需要整合多種通訊協定的裝置&lt;/td>
&lt;td>- 小型物聯網裝置、家電產品、工業控制等 &lt;br/> - 適合資源有限且需高即時性的情境&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>範例&lt;/strong>&lt;/td>
&lt;td>- 高度整合 SoC 平台 &lt;br/> - 網路裝置、醫療器械、消費性電子設備 &lt;br/> - 資源特別有限但需穩定度的系統&lt;/td>
&lt;td>- 物聯網邊緣設備 &lt;br/> - 小型感測器、可攜式產品 &lt;br/> - 工業自動化控制&lt;/td>
&lt;td>- 高速通訊設備 &lt;br/> - 需要完整追蹤與調試能力的工業設備 &lt;br/> - 精密儀器及高可靠度應用&lt;/td>
&lt;td>- 嵌入式微控制器 &lt;br/> - 智能家居與可穿戴式裝置 &lt;br/> - 需要快速啟動、高效率排程的場景&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="內核功能層面的差異">內核功能層面的差異
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>名稱&lt;/strong>&lt;/th>
&lt;th>&lt;strong>AzureRTOS (ThreadX)&lt;/strong>&lt;/th>
&lt;th>&lt;strong>FreeRTOS&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Zephyr&lt;/strong>&lt;/th>
&lt;th>&lt;strong>RT-Thread&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>內核架構&lt;/strong>&lt;/td>
&lt;td>- 輕量級、模組化設計 &lt;br/> - 單核心即時系統 &lt;br/> - 提供 preemption-threshold&lt;/td>
&lt;td>- 單核心設計 &lt;br/> - 透過設定檔自由啟用/停用功能 &lt;br/> - 針對 MCU 移植方便&lt;/td>
&lt;td>- 類微核心（microkernel）概念 &lt;br/> - Kconfig 編譯時可裁剪/擴充 &lt;br/> - 可支援多核心 (SMP)&lt;/td>
&lt;td>- 微核心 + 模組化 &lt;br/> - 通過 Packages 擴充 &lt;br/> - 預設核心輕量、啟動速度快&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>排程機制&lt;/strong>&lt;/td>
&lt;td>- 可搶先式多工 &lt;br/> - 優先順序排程 &lt;br/> - preemption-threshold 降低不必要的搶先&lt;/td>
&lt;td>- 可搶先式或協同式多工 &lt;br/> - 時間片 (time slicing) 可選 &lt;br/> - 任務通知提高效能&lt;/td>
&lt;td>- 可搶先式/協同式混合 &lt;br/> - 支援多核心下的任務搬移 &lt;br/> - 彈性設定時間片與搶先策略&lt;/td>
&lt;td>- 以優先順序為基礎的可搶先式 &lt;br/> - 切換開銷低 &lt;br/> - 適合時限嚴苛的應用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>中斷管理&lt;/strong>&lt;/td>
&lt;td>- 提供快速中斷響應 &lt;br/> - ISR 中可使用 IPC 原語 &lt;br/> - 建議複雜邏輯放在 Thread&lt;/td>
&lt;td>- 有完整的中斷優先級設定規範 &lt;br/> - 提供「FromISR」API 與核心互動 &lt;br/> - 避免高優先級中斷封鎖 RTOS 服務&lt;/td>
&lt;td>- 針對不同架構有對應方法 &lt;br/> - 允許在 ISR 後半段做較複雜處理 &lt;br/> - 支援 &lt;code>irq_offload&lt;/code>&lt;/td>
&lt;td>- 中斷入口/出口簡潔 &lt;br/> - 可在 ISR 裡做任務喚醒或 IPC &lt;br/> - 建議將重任務放在中斷後處理或 Task&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>任務通訊與同步&lt;/strong>&lt;/td>
&lt;td>- 提供 Semaphore、Mutex、Event Flags、Message Queue &lt;br/> - Block Pool / Byte Pool 作為底層資源&lt;/td>
&lt;td>- 有 Queue、Semaphore、Mutex、Event Group、Task Notification &lt;br/> - Queue 是核心溝通管道&lt;/td>
&lt;td>- 提供 Queue、FIFO、LIFO、Pipe、Mailbox、Semaphore、Mutex 等多樣化機制 &lt;br/> - 信號（Signals）/事件等高階通訊&lt;/td>
&lt;td>- 提供 Semaphore、Mutex、Event、Mailbox、Message Queue &lt;br/> - 模組化 API，易於擴充&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>記憶體管理&lt;/strong>&lt;/td>
&lt;td>- Block Pool（固定大小） &lt;br/> - Byte Pool（彈性分配） &lt;br/> - 適合小型系統&lt;/td>
&lt;td>- 多種 heap 實作 (heap1~heap5) &lt;br/> - 依需求選擇靜態或動態配置 &lt;br/> - 須注意配置 Semaphore / Mutex 以確保多任務安全&lt;/td>
&lt;td>- slab、mempool、heap 等多種分配策略 &lt;br/> - Kconfig 可細調 &lt;br/> - 需在編譯階段做良好配置&lt;/td>
&lt;td>- mempool、heap 二分法 &lt;br/> - 預設輕量動態分配算法 &lt;br/> - 可搭配自訂或高階 alloc 演算法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>除錯與追蹤&lt;/strong>&lt;/td>
&lt;td>- 可使用 TraceX 等工具 &lt;br/> - 整合度高，針對 Thread、Event、IPC 做可視化&lt;/td>
&lt;td>- FreeRTOS+Trace、第三方 IDE 追蹤工具多 &lt;br/> - 與 Percepio Tracealyzer 深度整合&lt;/td>
&lt;td>- 統一的 Tracing 子系統 &lt;br/> - 可連接 Tracealyzer、LTTng、SystemView 等 &lt;br/> - 追蹤支援度豐富&lt;/td>
&lt;td>- RT-Thread Studio 或其他插件 &lt;br/> - 提供簡單 log 系統與線上除錯機制 &lt;br/> - 社群亦有類似 FreeRTOS Trace 的追蹤方案&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>可移植性與擴充性&lt;/strong>&lt;/td>
&lt;td>- 官方主要支援多數 ARM、RISC-V、MIPS &lt;br/> - Microsoft 收購後社群逐漸擴大&lt;/td>
&lt;td>- 幾乎所有 MCU 都有移植 &lt;br/> - 大量第三方套件與驅動 &lt;br/> - 可透過 AWS FreeRTOS 延伸雲端功能&lt;/td>
&lt;td>- 原生支援多家大廠硬體 (Intel、NXP、Nordic&amp;hellip;) &lt;br/> - Kconfig + Devicetree 與 Linux 類似 &lt;br/> - 企業支援與社群並重&lt;/td>
&lt;td>- 在亞洲（特別是中國）用得廣泛 &lt;br/> - 與國產 MCU、RISC-V 平台整合度高 &lt;br/> - Packages 方式讓功能彈性擴充&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="總結">總結
&lt;/h2>&lt;p>總結一下前面提到的四種RTOS：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>AzureRTOS (ThreadX)&lt;/strong>：以高效能與小巧佔用聞名，擅長在嚴苛的資源受限環境中執行，另有良好的除錯工具與商業案例，對STM32的支援度好。&lt;/li>
&lt;li>&lt;strong>FreeRTOS&lt;/strong>：擁有巨大開源社群與靈活的擴充性，適用於廣泛的微控制器與嵌入式應用，在學術或商業專案皆常見，初學者適合。&lt;/li>
&lt;li>&lt;strong>Zephyr&lt;/strong>：受到 Linux 基金會與多家企業的大力推動，硬體支援廣泛，並有強大的追蹤與分析工具，適合需要高可靠度及詳細監控的中大型嵌入式應用&lt;/li>
&lt;li>&lt;strong>RT-Thread&lt;/strong>：架構輕量化、模組化明確，啟動速度快，適合物聯網及其他對即時性與資源效率要求高的場景。&lt;/li>
&lt;/ol></description></item><item><title>Zephyr RTOS 兩種建立Thread的方式</title><link>https://www.hugoshih.com/p/zephyr-rtos-%E5%85%A9%E7%A8%AE%E5%BB%BA%E7%AB%8Bthread%E7%9A%84%E6%96%B9%E5%BC%8F/</link><pubDate>Sun, 05 Jan 2025 22:20:31 +0800</pubDate><guid>https://www.hugoshih.com/p/zephyr-rtos-%E5%85%A9%E7%A8%AE%E5%BB%BA%E7%AB%8Bthread%E7%9A%84%E6%96%B9%E5%BC%8F/</guid><description>&lt;img src="https://i.imgur.com/V5OSNcL.jpg" alt="Featured image of post Zephyr RTOS 兩種建立Thread的方式" />&lt;h1 id="zephyr-rtos-兩種建立thread的方式">Zephyr RTOS 兩種建立Thread的方式
&lt;/h1>&lt;h2 id="thread-執行緒">Thread (執行緒)
&lt;/h2>&lt;p>在 Zephyr OS中，每個獨立的功能或任務可以放在不同的執行緒中執行，內部使用了輕量級的排程器，可以根據不同執行緒的優先級，以及執行緒本身的狀態（ready, running, pending 等），來決定哪一個執行緒能夠先被 CPU 執行，執行緒可以有以下幾個性質：&lt;/p>
&lt;ol>
&lt;li>執行緒優先級（Priority）：數值越小表示優先級越高（Preemptive scheduling 的情況下）。&lt;/li>
&lt;li>堆疊大小（Stack Size）：每個執行緒必須設定自己的堆疊空間，Zephyr 會在執行緒切換時儲存或恢復執行緒的上下文。&lt;/li>
&lt;li>執行緒生命週期（Lifecycle）：可以在編譯期就被預先配置好，或在執行期動態配置與建立。&lt;/li>
&lt;/ol>
&lt;h2 id="zephyr-建立執行緒的兩種常見方法">Zephyr 建立執行緒的兩種常見方法
&lt;/h2>&lt;h3 id="在編譯期間compile-time建立執行緒">在編譯期間（Compile Time）建立執行緒
&lt;/h3>&lt;p>Zephyr 提供了一個巨集 &lt;code>K_THREAD_DEFINE()&lt;/code> 用於在編譯期就宣告並建立執行緒。只要程式一開啟並初始化 RTOS 後，這些執行緒就會自動被建立並進入排程器的管理。&lt;/p>
&lt;h4 id="k_thread_define">K_THREAD_DEFINE()
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define K_THREAD_DEFINE(name, stack_size, entry_fn, p1, p2, p3, \
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"> prio, options, delay)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>name：此執行緒的識別名稱，同時會生成一個 k_tid_t 型態的變數。&lt;/li>
&lt;li>stack_size：此執行緒的堆疊大小（以 byte 為單位）。&lt;/li>
&lt;li>entry_fn：此執行緒進入點函式（thread function），開始執行時要跑哪個函式。&lt;/li>
&lt;li>p1, p2, p3：最多可傳入三個參數給進入點函式使用（都為 void* 型態）。&lt;/li>
&lt;li>prio：優先級（數值越小，優先級越高）。&lt;/li>
&lt;li>options：執行緒選項，通常先給 0 表示沒有特別的額外設定。&lt;/li>
&lt;li>delay：執行緒開始之前的延遲時間（ticks 或毫秒），若填 0 表示不延遲，立即就緒。&lt;/li>
&lt;/ul>
&lt;h3 id="在執行期間run-time建立執行緒">在執行期間（Run Time）建立執行緒
&lt;/h3>&lt;p>另一種是在程式運行期間建立執行緒，使用 API 函數&lt;code>k_thread_create()&lt;/code> 建立執行緒。這種方法在有些情況下會更具彈性，例如依據狀態或條件，動態啟動或終止執行緒，以免靜態建立過多浪費資源。&lt;/p>
&lt;h4 id="k_thread_create">k_thread_create()
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">k_tid_t&lt;/span> &lt;span class="nf">k_thread_create&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">k_thread&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">new_thread&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">k_thread_stack_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">stack_size&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">k_thread_entry_t&lt;/span> &lt;span class="n">entry&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">prio&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">options&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">k_timeout_t&lt;/span> &lt;span class="n">delay&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>new_thread：指向使用者自行宣告的 struct k_thread 物件，用來儲存此執行緒的控制區塊。&lt;/li>
&lt;li>stack：指向此執行緒對應的堆疊空間（需先以 &lt;code>K_THREAD_STACK_DEFINE()&lt;/code> 靜態或動態配置）。&lt;/li>
&lt;li>stack_size：此堆疊的大小。&lt;/li>
&lt;li>entry：執行緒執行的進入點函式。&lt;/li>
&lt;li>p1, p2, p3：最多可傳入三個參數到執行緒函式。&lt;/li>
&lt;li>prio：優先級。&lt;/li>
&lt;li>options：執行緒選項，常用為 0。&lt;/li>
&lt;li>delay：執行緒開始前是否要延遲。&lt;/li>
&lt;/ul>
&lt;h2 id="範例">範例
&lt;/h2>&lt;p>以下兩段程式碼，分別示範用 &lt;code>K_THREAD_DEFINE()&lt;/code>（在編譯期間）或 &lt;code>k_thread_create()&lt;/code>（在執行期間）建立兩個執行緒，分別執行 LED 漸亮漸暗（fade_led） 與 LED 閃爍（toggle_led） 的功能
&lt;a class="link" href="https://github.com/h920032/Zephyr-blinky-toggle-demo" target="_blank" rel="noopener"
>github repo&lt;/a>
以下是在Nucleo-F303K8的執行結果，左邊LED執行toggle，右邊執行fading
&lt;img src="https://imgur.com/V0jJ9bs.gif"
loading="lazy"
>&lt;/p>
&lt;h3 id="在編譯期間compile-time動態建立執行緒範例">在編譯期間（Compile Time）動態建立執行緒範例
&lt;/h3>&lt;ol>
&lt;li>&lt;code>K_THREAD_DEFINE(fade_tid, 512, fade_led, NULL, NULL, NULL, 5, 0, 0);&lt;/code>
&lt;ul>
&lt;li>建立一個名為 fade_tid 的執行緒，堆疊大小 512 bytes，執行函式為 fade_led，優先級 5。&lt;/li>
&lt;li>p1, p2, p3 都填 NULL，表示不需要傳遞參數。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>K_THREAD_DEFINE(toggle_tid, 512, toggle_led, NULL, NULL, NULL, 5, 0, 0);&lt;/code>
&lt;ul>
&lt;li>同樣建立名為 toggle_tid 的執行緒，stack大小、優先級參數與上面一致，執行函式為 toggle_led。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>這些執行緒在編譯的時候就已經被「靜態配置」了，所以當系統啟動並執行到 main() 時，它們也就由排程器自動啟動並不斷執行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/kernel.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/sys/printk.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/device.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/drivers/pwm.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;zephyr/drivers/gpio.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">fade_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">toggle_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 利用 DT_ALIAS(pwm_led0) 與 DT_ALIAS(led1) 取得裝置樹中的設備訊息
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">pwm_dt_spec&lt;/span> &lt;span class="n">pwm_led0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">PWM_DT_SPEC_GET&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">DT_ALIAS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">gpio_dt_spec&lt;/span> &lt;span class="n">led1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">GPIO_DT_SPEC_GET&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">DT_ALIAS&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">led1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">gpios&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 這裡定義一些常數用於控制漸亮漸暗的速度或節拍
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#define NUM_STEPS 256U
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define SLEEP_MSEC 5U
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define SLEEP_TIME_MS 500
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 在編譯期間靜態建立兩個執行緒
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">K_THREAD_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fade_tid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fade_led&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">K_THREAD_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">toggle_tid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">toggle_led&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// fade_led 會透過 PWM 設定脈寬來控制 LED 的亮度，製造 &amp;#34;呼吸燈&amp;#34; 效果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">fade_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">step&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">period&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">NUM_STEPS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint8_t&lt;/span> &lt;span class="n">dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 設定當前的脈寬
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">pwm_set_pulse_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pulse_width&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 調整脈寬，控制 LED 往漸亮或漸暗方向
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">dir&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pulse_width&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">period&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">period&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pulse_width&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pulse_width&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">step&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dir&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1U&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">k_sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">K_MSEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SLEEP_MSEC&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// toggle_led 會透過 GPIO pin toggle 的方式，使 LED 閃爍
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">toggle_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">gpio_pin_toggle_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">led1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">k_sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">K_MSEC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SLEEP_TIME_MS&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 檢查 PWM 裝置是否 ready
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">pwm_is_ready_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Error: PWM device %s is not ready&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">pwm_led0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 設定 GPIO pin 為輸出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">gpio_pin_configure_dt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">led1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GPIO_OUTPUT_ACTIVE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// main 函式結束後，兩個 K_THREAD_DEFINE 建立的執行緒依然會持續執行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="在執行期run-time動態建立執行緒範例">在執行期（Run Time）動態建立執行緒範例
&lt;/h3>&lt;p>若想要在程式執行的過程中（例如：由某個事件觸發）再建立執行緒，可以使用以下的做法：
1. 用 &lt;code>K_THREAD_STACK_DEFINE(my_stack_area, STACK_SIZE)&lt;/code>; 定義stack。
2. 定義一個 struct k_thread my_thread_data; 作為執行緒控制區塊（Thread Control Block, TCB）。
3. 呼叫 k_thread_create()，傳入上述的stack、控制區塊、進入點函式及其他參數來完成建立。&lt;/p>
&lt;p>以下是一個範例，展示如何在 main() 函式中動態建立執行緒（此示例僅顯示與執行緒有關的部分，省略週邊初始化等重複程式碼）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">前面的程式碼相同&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">*&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 宣告執行緒stack size
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="nf">K_THREAD_STACK_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fade_stack&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="nf">K_THREAD_STACK_DEFINE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">toggle_stack&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">512&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 宣告執行緒控制區塊
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">k_thread&lt;/span> &lt;span class="n">fade_thread_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">k_thread&lt;/span> &lt;span class="n">toggle_thread_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 這兩個函式和之前範例雷同
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">fade_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">toggle_led&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在執行期動態建立 fade_led thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">k_tid_t&lt;/span> &lt;span class="n">fade_tid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">k_thread_create&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">fade_thread_data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">my_fade_stack&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">K_THREAD_STACK_SIZEOF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_fade_stack&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fade_led&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">K_NO_WAIT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在執行期動態建立 toggle_led thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">k_tid_t&lt;/span> &lt;span class="n">toggle_tid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">k_thread_create&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">toggle_thread_data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">my_toggle_stack&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">K_THREAD_STACK_SIZEOF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">my_toggle_stack&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">toggle_led&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">K_NO_WAIT&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// k_thread_create 回傳 k_tid_t，可用於後續管理 thread
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 例如 k_thread_suspend(fade_tid), k_thread_resume(fade_tid), k_thread_abort(fade_tid)...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="比較">比較
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>建立方式&lt;/th>
&lt;th>特點&lt;/th>
&lt;th>典型使用時機&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Compile Time 建立&lt;/td>
&lt;td>&lt;code>K_THREAD_DEFINE()&lt;/code>&lt;/td>
&lt;td>一開始已知需要的執行緒，以及系統資源充足時&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Run Time 動態建立&lt;/td>
&lt;td>&lt;code>k_thread_create()&lt;/code>，在程式執行時期再分配資源&lt;/td>
&lt;td>不確定需要多少執行緒，或需要彈性創建／釋放&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>如果確定在整個系統的生命週期中，執行緒數量固定，或是系統比較單純（例如一個簡單的多任務控制），用編譯期方式能減少程式碼的複雜度，也能讓程式一啟動就快速就緒。&lt;/li>
&lt;li>如果系統中會動態產生／取消某些任務（如：偵測到新裝置才開新任務等），就可以使用動態建立的方式，提高系統彈性。&lt;/li>
&lt;/ol>
&lt;h2 id="總結">總結
&lt;/h2>&lt;ul>
&lt;li>靜態（編譯期）建立執行緒：
&lt;ul>
&lt;li>使用 &lt;code>K_THREAD_DEFINE()&lt;/code>&lt;/li>
&lt;li>簡單、快速、程式架構清晰&lt;/li>
&lt;li>適用於固定且少數的長期執行緒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>動態（執行期）建立執行緒：
&lt;ul>
&lt;li>使用 &lt;code>k_thread_create()&lt;/code>&lt;/li>
&lt;li>需要自行管理堆疊、控制區塊等&lt;/li>
&lt;li>適用於需要彈性創建和銷毀大量或不定數量執行緒的應用場景&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>
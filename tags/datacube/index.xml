<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Datacube on Hsing-Yu Shih</title><link>https://page.dipsyshih.com/tags/datacube/</link><description>Recent content in Datacube on Hsing-Yu Shih</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 22 Mar 2019 00:58:25 +0800</lastBuildDate><atom:link href="https://page.dipsyshih.com/tags/datacube/index.xml" rel="self" type="application/rss+xml"/><item><title>Datacube 函式筆記</title><link>https://page.dipsyshih.com/p/datacube-%E5%87%BD%E5%BC%8F%E7%AD%86%E8%A8%98/</link><pubDate>Fri, 22 Mar 2019 00:58:25 +0800</pubDate><guid>https://page.dipsyshih.com/p/datacube-%E5%87%BD%E5%BC%8F%E7%AD%86%E8%A8%98/</guid><description>&lt;img src="https://i.imgur.com/ilufKDH.png" alt="Featured image of post Datacube 函式筆記" />&lt;h1 id="datacube-函式筆記-基礎">Datacube 函式筆記-基礎&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>API函式&lt;/strong>：
可以參考這個網站：https://nbviewer.jupyter.org/github/opendatacube/datacube-core/blob/develop/examples/notebooks/Datacube_Summary.ipynb
官方函式說明：https://datacube-core.readthedocs.io/en/latest/_modules/index.html
調整圖片顏色：http://xarray.pydata.org/en/stable/plotting.html
範例包：https://nbviewer.jupyter.org/github/opendatacube/datacube-core/tree/develop/examples/notebooks/
xarray用法：https://xarray.pydata.org/en/stable/generated/xarray.Dataset.html#xarray.Dataset
&lt;a class="link" href="https://xarray.pydata.org/en/stable/api.html#dataarray" target="_blank" rel="noopener"
>https://xarray.pydata.org/en/stable/api.html#dataarray&lt;/a>
&lt;ol>
&lt;li>
&lt;p>：Datacube class，建立一個Datacube項目，用來導入Datacube資料庫時會用到&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">class datacube.Datacube(index=None, config=None, app=None,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">env=None, validate_connection=True)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>範例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import datacube
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dc = datacube.Datacube(app = &amp;#39;my_app&amp;#39;, config =
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;#39;/home/localuser/.datacube.conf&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#基本上就看你用的Datacube裡面的資料位置在哪，建議直接用
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>：Datacube.list_products() &amp;amp; Datacube.list_measurements()&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Datacube.list_products()&lt;/strong>：列出所有的衛星資料&lt;/li>
&lt;li>&lt;strong>Datacube.list_measurements()&lt;/strong>：列出衛星資料所含有的波段種類
範例：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">list_of_products = dc.list_products()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">netCDF_products = list_of_products[list_of_products[&amp;#39;format&amp;#39;] == &amp;#39;NetCDF&amp;#39;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">netCDF_products
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#list_of_products的參數就照上面設，我也不知道差別在哪
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#印出來就一個表格
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">list_of_measurements = dc.list_measurements()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">list_of_measurements
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#可以直接印出來，印出來也是一個表格
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>：Datacube.load()，建立一個xarray.Dataset用來儲存要撈的資料的各種參數&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Datacube.load(product = None, measurements = None, output_crs = None,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">resolution = None, resampling = None, dask_chunks = None,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">like = None, fuse_func = None, align = None,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">datasets = None, **query)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>範例1：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import datetime
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># define geographic boundaries in (min, max) format
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 用兩個變數來儲存要找的經緯度範圍(方框)，我也不知道多邊形怎麼用
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lon = (120.3697, 120.5044)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lat = (23.6686, 23.7476)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># define date range boundaries in (min,max) format
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 用datetime格式來儲存要提取資料的時間範圍
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">date_range =(datetime.datetime(2016,1,1),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">datetime.datetime(2017,6,30))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># define product and platform to specify our intent to
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#load Landsat 8 sr products
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">platform = &amp;#39;LANDSAT_8&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 衛星資料的模板，其實可以不用打，要打就不要打錯
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">product = &amp;#39;ls8_lasrc_taiwan&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 用來辨識讀取哪一個衛星的資料，絕對不能打錯
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># define desired bands.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">desired_bands =
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[&amp;#39;red&amp;#39;,&amp;#39;green&amp;#39;,&amp;#39;blue&amp;#39;,&amp;#39;nir&amp;#39;,&amp;#39;swir1&amp;#39;,&amp;#39;swir2&amp;#39;,&amp;#39;pixel_qa&amp;#39;]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 要提取的波段資料
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 以Landset8的話共有coastal_aerosol、blue、green、red、nir、swir1、swir2、
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># lwir1、lwir2、pixel_qa、sr_aerosol、radsat_qa這些波段，我們只提取了其中幾個，也可以在加
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 輸出的順序會按照陣列的裡的排列出現
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># load area. Should result in approximately 15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#acquisitions between 2014 and 2016
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">landsat = dc.load(product = product,platform = platform,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lat = lat,lon = lon,time = date_range,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">measurements = desired_bands)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">landsat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後實際把資料load出來，回傳的格式是xarray.Dataset
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>範例2：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">dc.load(product=&amp;#39;ls5_nbar_albers&amp;#39;, x=(148.15, 148.2), y=(-35.15, -35.2), time=(&amp;#39;1990&amp;#39;, &amp;#39;1991&amp;#39;),
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 時間座標等也可以用上面這種表示法
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">x=(1516200, 1541300), y=(-3867375, -3867350), crs=&amp;#39;EPSG:3577&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 也可以這樣，只是就要附註crs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 時間也可以用上面那種方法
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">output_crs=&amp;#39;EPSG:3577`, resolution=(-25, 25), resampling=&amp;#39;cubic&amp;#39;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>：Datacube.find_datasets()、Datacube.group_datasets()、Datacube.load_data()&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Datacube.find_datasets()&lt;/strong>：列出符合條件的影像資料位置，以list方式回傳&lt;/li>
&lt;li>&lt;strong>Datacube.group_datasets()&lt;/strong>：將上面find_datasets()回傳的list裡的資料group起來，也可以自己弄一個符合格式的檔案路徑list，然後一樣嘢可幫你group起來&lt;/li>
&lt;li>&lt;strong>Datacube.load_data()&lt;/strong>：把剛剛group起來的資料load出來&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Datacube.find_datasets(**search_terms)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 參數的部分要輸入一種特殊的Query型態，不過datacube怪怪的，不能import這種格式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 所以等下範例有直接輸入參數的方式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Datacube.group_datasets(datasets, group_by) # 放棄嘗試這個函式XDD 主要是不知道group_by參數要填什麼
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 就是傳入上面那個find_datasets return 的東西
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 會回傳先前看到的xarray.DataArray格式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Datacube.load_data(sources, geobox, measurements, resampling=None, fuse_func=None, dask_chunks=None, skip_broken_datasets=False)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 也是放棄嘗試這個函式XDD
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 傳入剛剛group_datasets弄好的xarray，然後傳出xarray.Dataset
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>範例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">dc.find_datasets(product = &amp;#39;ls8_lasrc_taiwan&amp;#39;, time = (&amp;#39;2016-01-01&amp;#39;, &amp;#39;2017-01-01&amp;#39;))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後就會回傳一個list，裡面有所有符合條件資料的位置
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>：加入crs資料
其實這步可以不用做，基本上就是把讀取的參數整合&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import xarray as xr
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import numpy as np
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># xarray是用來儲存讀取資料的格式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">combined_dataset = xr.merge([landsat])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Copy original crs to merged dataset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">combined_dataset = combined_dataset.assign_attrs(landsat.attrs)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">combined_dataset
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>：實際撈資料&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import time # 裡面有把時間轉為字串的函式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import rasterio # 將點狀資料轉成圖塊
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from dc_utilities import write_geotiff_from_xr # 這蠻重要的，可以將xr格式轉成geotiff格式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">def time_to_string(t): # 將時間轉為字串
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return time.strftime(&amp;#34;%Y_%m_%d_%H_%M_%S&amp;#34;, time.gmtime(t.astype(int)/1000000000))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 就採用`time.strftime`函數將時間轉為字串，等等用來加入檔名當中
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">def export_slice_to_geotiff(ds, path): # 將資料轉為實際的tiff檔案
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> write_geotiff_from_xr(path,ds.astype(np.float32),list(landsat.data_vars.keys()),crs=&amp;#34;EPSG:4326&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 在這裡引用了write_geotiff_from_xr()函數，path是新建的tiff檔案的路徑和檔名，
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # ds.astype(np.float32)是將原來資料裡的整數值轉為浮點數值，大概是因為這個函數只接受浮點數，
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # list(landsat.data_vars.keys())則是將這裡面所有的屬性質(就是nir、red、blue那些)轉成list形式而已
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 最後crs就不必說惹，可以試一下怎麼直接從原來那個xarray.Dataset讀取這個資料，手動輸入實在很智障
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#For each time slice in a dataset we call export_slice_to_geotif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">def export_xarray_to_geotiff(ds, path):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for t in ds.time: # 接著就根據xarrayDataset.time裡面的時間資料list一筆一筆抓出來處理
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> time_slice_xarray = ds.sel(time = t)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 先是搞一個新的xarray，然後把裡面的time換成單一的值(有點像是從一層抽出一片的感覺)，以便等會用write_geotiff_from_xr轉換
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> export_slice_to_geotiff(time_slice_xarray, path + &amp;#34;_&amp;#34; + time_to_string(t) + &amp;#34;.tif&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # 然後就呼叫export_slice_to_geotiff，其實就是write_geotiff_from_xr()函數
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#Start Export
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">output_dir = &amp;#34;/home/localuser/Datacube/data_cube_notebooks/NTUF_Hsing-Yu/ToTiffTest&amp;#34; # 存檔的路徑
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">if not os.path.exists(output_dir): # 資料夾存在就直接存，沒有就新建一個
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> os.makedirs(output_dir)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">export_xarray_to_geotiff(landsat, &amp;#34;{}/{}&amp;#34;.format(output_dir,product))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># &amp;#34;{}/{}&amp;#34;.format(output_dir,product)的用法還沒有研究
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>：資料繪圖plot()
在xarray.Dataset的格式下可以直接呼叫plot()函數匯出影像&lt;/p>
&lt;ul>
&lt;li>&lt;strong>範例1：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">autumn = nbar.green.loc[&amp;#39;1991-3&amp;#39;:&amp;#39;1991-5&amp;#39;] # 圖檔的話好像只能用單一波段繪圖， 所以這邊要選擇你要的波段
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 這邊是選綠色，然後後面那邊可以設定時間區間，似乎也是可以不用設定！？
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn.shape # 看一下格式這樣
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn.plot(col=&amp;#39;time&amp;#39;, col_wrap=3) # 然後印出圖形，橫軸按照時間排列，每一排三個
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 印出來之後就向下圖這樣
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/LiOMvUZ.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>範例2：去除nodata的版本：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">autumn_valid = autumn.where(autumn != autumn.attrs[&amp;#39;nodata&amp;#39;]) # 新建一個變數，用來儲存去除nodata的資料
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn_valid.plot(col=&amp;#39;time&amp;#39;, col_wrap=3) # 然後一樣輸出
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/YZHQWlN.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>範例3：去除雲&lt;/strong>
在landsat5以後的衛星資料會提供一個pixelquality波段，通常是用來表示該相素的含雲量，有幾個特定的值是表示該像素是可以用的，不過我忘了&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">pq = dc.load(product=&amp;#39;ls5_pq_albers&amp;#39;, x=(149.25, 149.35), y=(-35.25, -35.35))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 一樣先load做出xarray.Dataset ，可以注意到這邊load的版本是ls5_pq_albers，跟前面load的nbar版本不一樣
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pq_autumn = pq.pixelquality.loc[&amp;#39;1991-3&amp;#39;:&amp;#39;1991-5&amp;#39;] # 然後一樣，只是改成以pixelquality波段作圖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pq_autumn.plot(col=&amp;#39;time&amp;#39;, col_wrap=3) # 顯示出來就像下面那樣
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/aUUzZnB.png"
loading="lazy"
>
可以注意到有特殊顏色的就是含雲量較高的像素，正常應該是黃色，所以等等要將這些有色區塊去除
這邊會用到masking工具，可以從datacube.storage中取出來&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">from datacube.storage import masking # 取出masking工具
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import pandas
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pandas.DataFrame.from_dict(masking.get_flags_def(pq), orient=&amp;#39;index&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 這裡的masking.get_flags_def(pq)，是從原來的xarray.Dataset找到如何判斷pixelquality值的表
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後就會得到一個對照表
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">good_data = masking.make_mask(pq, cloud_acca=&amp;#39;no_cloud&amp;#39;, cloud_fmask=&amp;#39;no_cloud&amp;#39;, contiguous=True)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 接下來要建立一個新的mask，mask上顏色不同的地方就是判定有雲的地方
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 根據前面的表，只要把cloud_acca和cloud_fmask這兩個變數都設為&amp;#39;no_cloud&amp;#39;，而contiguous=True則是表示這個pixel還含有其他波段，
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 可以試試設成false會怎樣
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 這樣就可以做出一個mask
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn_good_data = good_data.pixelquality.loc[&amp;#39;1991-3&amp;#39;:&amp;#39;1991-5&amp;#39;] # 然後再一次實際套用到剛剛的xarray.Dataset上
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn_good_data.plot(col=&amp;#39;time&amp;#39;, col_wrap=3) # 印出來就如下圖
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/0o5VUvz.png"
loading="lazy"
>
可以發現，現在不是黃色就是紫色
最後拿去跟一開始有綠色波段且做過nodata處理的那張圖疊&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">autumn_cloud_free = autumn_valid.where(autumn_good_data) # 就跟用來疊nodata的作法一樣
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn_cloud_free.plot(col=&amp;#39;time&amp;#39;, col_wrap=3) # 印出來就像下面那樣
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/4jtH7yl.png"
loading="lazy"
>
可以發現原本有雲的地方都變成無資料了，因為mask裡面，有雲的地方，數字被設為0，沒有雲的地方為1&lt;/p>
&lt;p>後來發現mask不給力，landsat8的資料不太能用，因此我就直接用where取出pixel_qa為322的資料
範例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">autumn = combined_dataset.green.where(combined_dataset.pixel_qa == 322)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 取值為322的資料，這是landsat8中品質最好的資料
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn_valid = autumn.where(autumn != autumn.attrs[&amp;#39;nodata&amp;#39;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 一樣清除nodata
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn_valid.plot(col=&amp;#39;time&amp;#39;, col_wrap=10)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 印出來就像下面那樣(顏色沒有調得很好XDD)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/jKdyrYy.png"
loading="lazy"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：將圖群組化(超重要！！)
有時候因為衛星軌道的關係，一個地區的影像會被切成兩三張圖放，用Group可將時間相近的圖整合成一張&lt;/p>
&lt;ul>
&lt;li>&lt;strong>範例：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">nbar_by_solar_day = dc.load(product=&amp;#39;ls5_nbar_albers&amp;#39;, x=(149.25, 149.35), y=(-35.25, -35.35), group_by=&amp;#39;solar_day&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 大部分跟之前用load()的方式差不多，只是在最後加了group_by=&amp;#39;solar_day&amp;#39;就是根據太陽日的範圍群組化圖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">len(nbar_by_solar_day.time) # 看一下圖是不是真的變少了
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">autumn2 = nbar_by_solar_day.green.loc[&amp;#39;1991-3&amp;#39;:&amp;#39;1991-5&amp;#39;] # 一樣取出綠色的波段作圖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autumn2.shape
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">autumn2.plot(col=&amp;#39;time&amp;#39;, col_wrap=3) # 一樣畫出圖，就變下面那樣
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/XJzQQ6L.png"
loading="lazy"
>
可以發現原來切掉的部分不見了！！！&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：算ndvi
就用red和nir這兩個波段算出ndvi，大概就是可以反映出地面物是不是植物這樣
red就是紅光，nir就是近紅外光&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">two_bands = dc.load(product=&amp;#39;ls5_nbar_albers&amp;#39;, x=(149.07, 149.17), y=(-35.25, -35.35), time=(&amp;#39;1991&amp;#39;, &amp;#39;1992&amp;#39;), measurements=[&amp;#39;red&amp;#39;, &amp;#39;nir&amp;#39;], group_by=&amp;#39;solar_day&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 跟前面使用load()的方式差不多，不過這次要用measurements，同時只load&amp;#39;red&amp;#39;, &amp;#39;nir&amp;#39;這兩個波段，一樣要記得用group_by
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">red = two_bands.red.where(two_bands.red != two_bands.red.attrs[&amp;#39;nodata&amp;#39;]) # 然後去除nodata
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nir = two_bands.nir.where(two_bands.nir != two_bands.nir.attrs[&amp;#39;nodata&amp;#39;]) # 也是去除nodata
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pq = dc.load(product=&amp;#39;ls5_pq_albers&amp;#39;, x=(149.07, 149.17), y=(-35.25, -35.35), time=(&amp;#39;1991&amp;#39;, &amp;#39;1992&amp;#39;), group_by=&amp;#39;solar_day&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後load另一個圖(是pq版本的)，等等用來做could free的mask
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cloud_free = masking.make_mask(pq, cloud_acca=&amp;#39;no_cloud&amp;#39;, cloud_fmask=&amp;#39;no_cloud&amp;#39;, contiguous=True).pixelquality
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 用之前坐的那張圖做一個mask，一樣取出pixelquality的部分
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ndvi = ((nir - red) / (nir + red)).where(cloud_free)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 拿nir和red這兩張圖算一下ndvi，然後跟cloud_free疊加，去除雲的部分
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ndvi.shape # 看一下資料量
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ndvi.plot(col=&amp;#39;time&amp;#39;, col_wrap=5) # 印出來，就像下面那樣
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/SsOBuDA.png"
loading="lazy"
>
其實還是有很多地方被切掉XDD，而且圖像的品質參差，接下來可以取出影像品質比較好的幾張，也就是含雲量較少的&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_cloud_free = cloud_free.sum(dim=(&amp;#39;x&amp;#39;,&amp;#39;y&amp;#39;)) &amp;gt; (0.75 * cloud_free.size / cloud_free.time.size)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 簡單來說就是找含雲量前25%少的圖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mostly_good_ndvi = ndvi.where(mostly_cloud_free).dropna(&amp;#39;time&amp;#39;, how=&amp;#39;all&amp;#39;) # 然後拿去跟原來的疊，刪掉雲多的圖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.plot(col=&amp;#39;time&amp;#39;, col_wrap=5) # 印出來
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/biR5vE2.png"
loading="lazy"
>
就發現只剩清晰的圖了
以下是我用先前桃園市的資料算的ndvi&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">red = combined_dataset.red.where(combined_dataset.red != combined_dataset.red.attrs[&amp;#39;nodata&amp;#39;]).where(combined_dataset.pixel_qa == 322)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nir = combined_dataset.nir.where(combined_dataset.nir != combined_dataset.nir.attrs[&amp;#39;nodata&amp;#39;]).where(combined_dataset.pixel_qa == 322)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 跟上面差不多，取出red和nir兩個波段，然後用where取出pixel_qa為322的地方
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ndvi = ((nir - red) / (nir + red)).where(ndvi &amp;lt;= 1).where(ndvi &amp;gt;= -1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 套個ndvi的公式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ndvi.shape
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ndvi.plot(col=&amp;#39;time&amp;#39;, col_wrap=5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 印出來
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/qAhJJWt.jpg"
loading="lazy"
>
接下來挑選一下雲含量比較少的圖&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">cloud_free = combined_dataset.pixel_qa.where(combined_dataset.pixel_qa != combined_dataset.pixel_qa.attrs[&amp;#39;nodata&amp;#39;]).where(combined_dataset.pixel_qa == 322) / 322
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 這邊就用先前pixel_qa的圖，抓值為322的部分，rescale為1，偽造成一個mask
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#cloud_free.plot(col=&amp;#39;time&amp;#39;, col_wrap=3)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mostly_cloud_free = cloud_free.sum(dim=(&amp;#39;latitude&amp;#39;,&amp;#39;longitude&amp;#39;)) &amp;gt; (0.75 * cloud_free.size / cloud_free.time.size)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後去算裡面不是雲的資料的比例，其實就是把它加總這樣
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mostly_good_ndvi = ndvi.where(mostly_cloud_free).dropna(&amp;#39;time&amp;#39;, how=&amp;#39;all&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後疊一下圖
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.plot(col=&amp;#39;time&amp;#39;, col_wrap=5)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 印出來
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/ilufKDH.png"
loading="lazy"
>
第一張圖估計是系統弄錯惹，都是雲，但值是322，將就著看吧
接下來ndvi還可以組一張中位數的圖，有點類似平均值的概念，可以看大範圍完整的樣子，不會受到圖片卻失的影響&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.median(dim=&amp;#39;time&amp;#39;).plot()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 就是取出每一個pixel的中位數，組成一張圖，這個函式還蠻厲害ㄉ
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/sIwU3Hr.png"
loading="lazy"
>
印出來就像這樣，顏色較深的地方大概就是沒有植物啦哈哈
p.s.為什麼不用平均數呢？因為平均數會受到nodata的影響
然後也可以做一張std的圖，表示變化程度&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.std(dim=&amp;#39;time&amp;#39;).plot()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 概念跟剛剛median差不多
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/7Nl2H8e.png"
loading="lazy"
>
顏色較淺的地方就是變化量較大的地方，ndvi會隨季節變化，這個大家都知道ㄉ，所以一樣，亮的地方就是有植物的地方&lt;/p>
&lt;p>然後也可以抓單一一點的ndvi變化，所以我隨便用google map選了一點
引用sel函式，後面輸入參數，可以讀出該座標上每個時間的值&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.sel(latitude=24.958132, longitude=121.126085, method=&amp;#39;nearest&amp;#39;).plot()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/Out4BAu.png"
loading="lazy"
>
畫出來的圖，某種程度上還是會受到nodata的影響&lt;/p>
&lt;p>下面這個是範例的奇妙用法，好像是抓出ndvi趨勢的感覺，詳細機制還要再研究&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.isel(latitude=[200], longitude=[200]).plot()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 那個兩百我不知道是要幹嘛的，我有試試看其他值，但跑出來的圖都怪怪的
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/0iFxSwE.png"
loading="lazy"
>
這張圖就可以很明顯的看到ndvi的季節性變化了&lt;/p>
&lt;p>接下來也是範例的奇妙用法，可以固定緯度，將不同時間的情況列出來&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.isel(longitude=30).plot()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 30的意義好像是代表longitude的第30個pixel
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/bug1KLd.png"
loading="lazy"
>
這樣一比對還真的可以看出明顯的季節變化&lt;/p>
&lt;p>另外還可以抓出特定幾個點比較時間的影響&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mostly_good_ndvi.isel_points(latitude=[0, 10, 20, 30, 40, 50], longitude=[20, 30, 40, 50, 60, 70]).plot(x=&amp;#39;points&amp;#39;, y=&amp;#39;time&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 同上那些數值也是以座標而言的第幾個點這樣
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/oEY66gD.png"
loading="lazy"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：多頻譜製圖(不是做成tif)
玩久了之後還是會想要做一張彩色的圖自爽一下
以下的方法就可以惹&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">rgb = dc.load(product=product, lon=lon, lat=lat, time=date_range, measurements=[&amp;#39;red&amp;#39;, &amp;#39;green&amp;#39;, &amp;#39;blue&amp;#39;], group_by=&amp;#39;solar_day&amp;#39;).to_array(dim=&amp;#39;color&amp;#39;).transpose(&amp;#39;time&amp;#39;, &amp;#39;latitude&amp;#39;, &amp;#39;longitude&amp;#39;, &amp;#39;color&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 前面坐過很多次了，就不贅述，紅綠藍波段一定要load近來，load了其他波段我不知道會怎樣，有空再試試
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 後面就是新建一個dim為新的color
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">zip(rgb.dims, rgb.shape)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 有沒有做這個zip其實沒差
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">fake_saturation = 3000
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 這個是用來當作影像值得上限，超過就用3000取代
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">clipped_visible = rgb.where(rgb &amp;lt; fake_saturation).fillna(fake_saturation)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 上面這邊就是這樣做，透過fillna()函式可以填入值
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max_val = clipped_visible.max([&amp;#39;latitude&amp;#39;, &amp;#39;longitude&amp;#39;])
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 然後找最大的scale
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scaled = (clipped_visible / max_val)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 設定scaled
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">from matplotlib import pyplot as plt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">plt.imshow(scaled.isel(time=19))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 最後就印出來，記得要import該import的東西
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://i.imgur.com/ziPdkS2.png"
loading="lazy"
>
選了一張被雲遮比較少ㄉ&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：將xarray.Dataarray製成Dataset
&lt;a class="link" href="http://xarray.pydata.org/en/stable/generated/xarray.DataArray.to_dataset.html" target="_blank" rel="noopener"
>http://xarray.pydata.org/en/stable/generated/xarray.DataArray.to_dataset.html&lt;/a>
&lt;a class="link" href="https://stackoverflow.com/questions/38826505/python-xarray-add-dataarray-to-dataset" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/38826505/python-xarray-add-dataarray-to-dataset&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：Dataarray or Dataset中的資料型別轉換
&lt;a class="link" href="http://xarray.pydata.org/en/stable/generated/xarray.DataArray.astype.html" target="_blank" rel="noopener"
>http://xarray.pydata.org/en/stable/generated/xarray.DataArray.astype.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：不想要用.varibales的替代方案.get()
&lt;a class="link" href="https://github.com/pydata/xarray/issues/1801" target="_blank" rel="noopener"
>https://github.com/pydata/xarray/issues/1801&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>：將matplotlib畫出的東西輸出成png
&lt;a class="link" href="https://stackoverflow.com/questions/9622163/save-plot-to-image-file-instead-of-displaying-it-using-matplotlib" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/9622163/save-plot-to-image-file-instead-of-displaying-it-using-matplotlib&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="datacube-函式筆記-進階">Datacube 函式筆記-進階&lt;/h1>
&lt;ul>
&lt;li>WOFs&lt;/li>
&lt;/ul>
&lt;h1 id="datacube-函式筆記-其他">Datacube 函式筆記-其他&lt;/h1>
&lt;ul>
&lt;li>文件解壓縮
在可以使用sever Shell的情況下，通常將文件打包(.zip)上傳之後再用Linux下的unzip解壓縮，不過新版的jupyter介面將Shell的功能關惹，所以只能用python內建的函式庫解壓縮，程式如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import os,zipfile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">def un_zip(file_name):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;#34;&amp;#34;&amp;#34;unzip zip file&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> zip_file = zipfile.ZipFile(file_name)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if os.path.isdir(file_name + &amp;#34;_files&amp;#34;):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pass
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> os.mkdir(file_name + &amp;#34;_files&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for names in zip_file.namelist():
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> zip_file.extract(names,file_name + &amp;#34;_files/&amp;#34;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> zip_file.close()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">un_zip(&amp;#34;utils.zip&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用方式：先用%指令切換到正確的工作目錄，然後啟動run上面的程式&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">import os, zipfile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#打包目录为zip文件（未压缩）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">def make_zip(source_dir, output_filename):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> zipf = zipfile.ZipFile(output_filename, &amp;#39;w&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pre_len = len(os.path.dirname(source_dir))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for parent, dirnames, filenames in os.walk(source_dir):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for filename in filenames:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> print(filename)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pathfile = os.path.join(parent, filename)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> arcname = pathfile[pre_len:].strip(os.path.sep) #相对路径
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> zipf.write(pathfile, arcname)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> print()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> zipf.close()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make_zip(r&amp;#34;E:\python_sample\libs\test_tar_files\libs&amp;#34;,&amp;#34;test.zip&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Jupyter使用終端機指令
雖然終止了shell的使用，但一樣可以在Jupyter使用Linux指令，不過一樣會受到權限限制
ex:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">% ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">% cd ~
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">% pwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>